<!DOCTYPE html>
<html lang="fr" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>V‑MACH • Production Badges</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#5ab7a4" />

  <!-- Fonts & Favicon -->
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
    rel="stylesheet"
  />
  <link
    rel="icon"
    type="image/png"
    href="https://djuqbvg97u5zb.cloudfront.net/vmachonpr/images/websitelogos/retailer_site_logo88.png"
  />

  <style>

    :root {
      --radius-lg: 24px;
      --radius-md: 18px;
      --radius-sm: 12px;
      --touch: 52px;
      --safe-bottom: env(safe-area-inset-bottom, 18px);
      --header-h: 208px;
      --page-pad: clamp(18px, 4vw, 48px);
      font-size: 16px;
    }
    [data-theme="dark"] {
      color-scheme: dark;
      --bg: #050910;
      --bg-alt: #081120;
      --surface: rgba(13, 21, 34, 0.92);
      --surface-strong: #0f1a2b;
      --surface-soft: rgba(16, 26, 42, 0.78);
      --stroke: rgba(104, 150, 206, 0.18);
      --text: #f4f6fb;
      --muted: #9aa7c2;
      --text-muted: rgba(231, 236, 247, 0.75);
      --text-subtle: rgba(231, 236, 247, 0.62);
      --text-soft: rgba(244, 246, 251, 0.68);
      --text-placeholder: rgba(220, 229, 242, 0.45);
      --text-faint: rgba(220, 229, 242, 0.38);
      --ghost-text: rgba(226, 236, 248, 0.85);
      --border-subtle: rgba(255, 255, 255, 0.16);
      --control-bg: rgba(255, 255, 255, 0.05);
      --control-border: rgba(255, 255, 255, 0.08);
      --ghost-bg: rgba(255, 255, 255, 0.04);
      --ghost-border: rgba(255, 255, 255, 0.22);
      --ghost-hover-bg: rgba(90, 183, 164, 0.14);
      --ghost-hover-border: rgba(90, 183, 164, 0.58);
      --ghost-hover-text: var(--accent);
      --ghost-active-bg: rgba(90, 183, 164, 0.2);
      --ghost-active-border: rgba(90, 183, 164, 0.68);
      --ghost-active-text: var(--accent);
      --chip-active-border: rgba(90, 183, 164, 0.5);
      --note-bg: rgba(14, 26, 44, 0.85);
      --note-border: rgba(255, 255, 255, 0.1);
      --note-text: rgba(226, 234, 247, 0.78);
      --accent: #5ab7a4;
      --accent-2: #7387d7;
      --accent-soft: rgba(90, 183, 164, 0.2);
      --warn: #f2b36a;
      --danger: #f07a8d;
      --ok: #68d4ac;
      --btn-bg: rgba(10, 20, 36, 0.82);
      --btn-border: rgba(255, 255, 255, 0.08);
      --btn-text: #f4f6fb;
      --btn-pause-bg: rgba(242, 179, 106, 0.24);
      --btn-pause-border: rgba(242, 179, 106, 0.5);
      --btn-pause-text: #2f1f0f;
      --btn-done-bg: rgba(104, 212, 172, 0.24);
      --btn-done-border: rgba(104, 212, 172, 0.48);
      --btn-done-text: #062822;
      --btn-del-bg: rgba(240, 122, 141, 0.26);
      --btn-del-border: rgba(240, 122, 141, 0.45);
      --btn-del-text: #ffeef2;
      --input-bg: rgba(9, 16, 28, 0.88);
      --input-text: #f4f6fb;
      --input-border: rgba(255, 255, 255, 0.12);
      --input-focus-border: rgba(90, 183, 164, 0.45);
      --input-focus-ring: rgba(90, 183, 164, 0.14);
      --brand-gradient: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
      --shadow-lg: 0 24px 46px rgba(4, 8, 20, 0.55);
      --shadow-md: 0 14px 32px rgba(5, 10, 25, 0.45);
      --header-bg: linear-gradient(185deg, rgba(7, 12, 24, 0.94) 0%, rgba(7, 12, 24, 0.68) 100%);
      --header-border: rgba(255, 255, 255, 0.08);
      --header-shadow: 0 24px 46px rgba(4, 8, 20, 0.55);
      --header-sticky-shadow: 0 18px 32px rgba(4, 8, 20, 0.55);
      --header-overlay: linear-gradient(185deg, rgba(7, 12, 24, 0.96), rgba(7, 12, 24, 0.72));
      --header-icon-bg: linear-gradient(145deg, rgba(255, 255, 255, 0.14) 0%, rgba(255, 255, 255, 0.02) 100%),
        var(--surface);
      --header-icon-border: rgba(255, 255, 255, 0.12);
      --header-icon-shadow: 0 10px 26px rgba(6, 12, 24, 0.45);
      --chip-bg: rgba(255, 255, 255, 0.05);
      --chip-border: rgba(255, 255, 255, 0.12);
      --chip-active-shadow: 0 8px 18px rgba(6, 27, 24, 0.4);
      --field-bg: rgba(16, 26, 42, 0.9);
      --field-border: rgba(255, 255, 255, 0.1);
      --field-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
      --insight-bg: linear-gradient(165deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0)),
        var(--surface);
      --insight-border: rgba(255, 255, 255, 0.12);
      --insight-card-bg: linear-gradient(165deg, rgba(115, 135, 215, 0.16) 0%, rgba(90, 183, 164, 0.08) 75%),
        var(--surface-soft);
      --insight-card-border: rgba(255, 255, 255, 0.08);
      --insight-card-shadow: 0 18px 32px rgba(4, 10, 24, 0.35);
      --insight-card-highlight: radial-gradient(circle at top right, rgba(115, 135, 215, 0.16), transparent 60%);
      --card-bg: linear-gradient(155deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0) 80%), var(--surface);
      --card-border: rgba(255, 255, 255, 0.08);
      --badge-bg: rgba(115, 135, 215, 0.22);
      --badge-border: rgba(115, 135, 215, 0.5);
      --badge-text: #e2e6fb;
      --badge-pause-bg: rgba(242, 179, 106, 0.26);
      --badge-pause-border: rgba(242, 179, 106, 0.58);
      --badge-pause-text: #2f1f0f;
      --badge-done-bg: rgba(90, 183, 164, 0.28);
      --badge-done-border: rgba(90, 183, 164, 0.6);
      --badge-done-text: #062822;
      --insight-progress-bg: rgba(255, 255, 255, 0.08);
    }
    [data-theme="light"] {
      color-scheme: light;
      --bg: #f5f7fa;
      --bg-alt: #ffffff;
      --surface: rgba(255, 255, 255, 0.94);
      --surface-strong: #ffffff;
      --surface-soft: rgba(237, 242, 250, 0.78);
      --stroke: rgba(96, 120, 168, 0.16);
      --text: #1f2937;
      --muted: #5c687a;
      --text-muted: #556173;
      --text-subtle: #6a7688;
      --text-soft: #5f6c80;
      --text-placeholder: #8b97aa;
      --text-faint: #9aa5b5;
      --ghost-text: #274b53;
      --border-subtle: rgba(31, 41, 55, 0.14);
      --control-bg: rgba(63, 136, 121, 0.12);
      --control-border: rgba(63, 136, 121, 0.24);
      --ghost-bg: rgba(63, 136, 121, 0.1);
      --ghost-border: rgba(63, 136, 121, 0.28);
      --ghost-hover-bg: rgba(63, 136, 121, 0.18);
      --ghost-hover-border: rgba(63, 136, 121, 0.45);
      --ghost-hover-text: var(--accent);
      --ghost-active-bg: rgba(63, 136, 121, 0.2);
      --ghost-active-border: rgba(63, 136, 121, 0.52);
      --ghost-active-text: var(--accent);
      --chip-active-border: rgba(63, 136, 121, 0.36);
      --note-bg: rgba(63, 136, 121, 0.12);
      --note-border: rgba(63, 136, 121, 0.32);
      --note-text: #2d4f47;
      --accent: #3f8879;
      --accent-2: #5d6ed6;
      --accent-soft: rgba(63, 136, 121, 0.16);
      --warn: #d7964b;
      --danger: #ce546d;
      --ok: #2e9e78;
      --btn-bg: #3f8879;
      --btn-border: #2f6c5f;
      --btn-text: #ffffff;
      --btn-pause-bg: #f0b47a;
      --btn-pause-border: #ca7f38;
      --btn-pause-text: #432a0e;
      --btn-done-bg: #45b892;
      --btn-done-border: #31886a;
      --btn-done-text: #ffffff;
      --btn-del-bg: #ce546d;
      --btn-del-border: #a53d54;
      --btn-del-text: #ffffff;
      --input-bg: #ffffff;
      --input-text: #1f2937;
      --input-border: rgba(28, 51, 101, 0.18);
      --input-focus-border: rgba(63, 136, 121, 0.45);
      --input-focus-ring: rgba(63, 136, 121, 0.18);
      --brand-gradient: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
      --shadow-lg: 0 24px 40px rgba(28, 45, 82, 0.12);
      --shadow-md: 0 14px 28px rgba(24, 42, 78, 0.1);
      --header-bg: linear-gradient(185deg, rgba(255, 255, 255, 0.96) 0%, rgba(239, 244, 255, 0.88) 100%);
      --header-border: rgba(31, 41, 55, 0.12);
      --header-shadow: 0 24px 36px rgba(28, 45, 82, 0.14);
      --header-sticky-shadow: 0 18px 24px rgba(28, 45, 82, 0.12);
      --header-overlay: linear-gradient(185deg, rgba(255, 255, 255, 0.96), rgba(239, 244, 255, 0.78));
      --header-icon-bg: linear-gradient(145deg, rgba(255, 255, 255, 0.96) 0%, rgba(239, 244, 255, 0.82) 100%),
        var(--surface);
      --header-icon-border: rgba(31, 41, 55, 0.16);
      --header-icon-shadow: 0 12px 24px rgba(28, 45, 82, 0.15);
      --chip-bg: rgba(63, 136, 121, 0.12);
      --chip-border: rgba(63, 136, 121, 0.26);
      --chip-active-shadow: 0 8px 18px rgba(63, 136, 121, 0.28);
      --field-bg: #ffffff;
      --field-border: rgba(28, 51, 101, 0.18);
      --field-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      --insight-bg: linear-gradient(165deg, rgba(63, 136, 121, 0.14), rgba(93, 110, 214, 0.08)),
        var(--surface);
      --insight-border: rgba(31, 41, 55, 0.12);
      --insight-card-bg: linear-gradient(165deg, rgba(93, 110, 214, 0.14) 0%, rgba(63, 136, 121, 0.08) 75%),
        var(--surface-soft);
      --insight-card-border: rgba(63, 136, 121, 0.2);
      --insight-card-shadow: 0 18px 32px rgba(63, 136, 121, 0.18);
      --insight-card-highlight: radial-gradient(circle at top right, rgba(93, 110, 214, 0.2), transparent 60%);
      --card-bg: linear-gradient(155deg, rgba(63, 136, 121, 0.12) 0%, rgba(93, 110, 214, 0.08) 80%), var(--surface);
      --card-border: rgba(31, 41, 55, 0.12);
      --badge-bg: rgba(101, 138, 214, 0.18);
      --badge-border: rgba(101, 138, 214, 0.34);
      --badge-text: #29406d;
      --badge-pause-bg: rgba(240, 180, 122, 0.28);
      --badge-pause-border: rgba(202, 127, 56, 0.54);
      --badge-pause-text: #513312;
      --badge-done-bg: rgba(63, 136, 121, 0.24);
      --badge-done-border: rgba(63, 136, 121, 0.5);
      --badge-done-text: #0f372d;
      --insight-progress-bg: rgba(31, 41, 55, 0.12);
    }

    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      overflow-x: clip;
      overscroll-behavior-x: contain;
      background:
        radial-gradient(120% 130% at 20% -10%, rgba(115, 135, 215, 0.22) 0%, transparent 55%),
        radial-gradient(120% 160% at 80% 0%, rgba(90, 183, 164, 0.18) 0%, transparent 60%),
        linear-gradient(180deg, var(--bg) 0%, var(--bg-alt) 100%);
      color: var(--text);
      padding: var(--page-pad);
    }
    .page-grid {
      width: min(1280px, 100%);
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      grid-template-areas:
        "header"
        "list";
      gap: clamp(18px, 3.5vw, 36px);
      align-items: start;
    }
    .page-main {
      grid-area: list;
      display: grid;
      gap: clamp(18px, 3vw, 28px);
      padding: clamp(22px, 3.5vw, 32px);
      border-radius: var(--radius-lg);
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0) 85%),
        var(--surface);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: var(--shadow-lg);
      min-height: 0;
      padding-bottom: calc(140px + var(--safe-bottom));
    }

    @media (max-width: 720px) {
      :root {
        --page-pad: 20px;
        --radius-lg: 20px;
        --radius-md: 16px;
        --radius-sm: 12px;
      }
      body {
        padding: 0;
      }
      .page-grid {
        width: 100%;
        margin: 0;
        padding: 0;
        gap: 0;
      }
      header.page-header {
        position: sticky;
        top: 0;
        border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        box-shadow: var(--header-sticky-shadow);
      }
      header.page-header::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: var(--header-overlay);
        background-size: 180% 180%;
        animation: headerBreath 30s ease-in-out infinite;
        opacity: 0.85;
        filter: none;
        z-index: -1;
      }
      .topbar {
        padding: calc(env(safe-area-inset-top, 0) + clamp(18px, 6vw, 28px)) var(--page-pad)
          clamp(16px, 5vw, 24px);
      }
      .chip-row {
        margin: 0;
        padding-bottom: 4px;
      }
      .chip-row .chip {
        padding: 10px 18px;
        font-size: 0.85rem;
      }
      .utility {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .search input {
        min-height: 46px;
        font-size: 1rem;
      }
      .smart-badge {
        width: 100%;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
      }
      .page-main {
        border-radius: 0;
        margin: 0;
        padding: 22px var(--page-pad) calc(140px + var(--safe-bottom));
      }
      #list {
        gap: 16px;
      }
      .card {
        border-radius: var(--radius-md);
        padding: 20px 18px 18px;
      }
      #insights {
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        max-height: none;
        border-radius: 0;
        padding: calc(env(safe-area-inset-top, 0) + 24px) var(--page-pad) calc(28px + var(--safe-bottom));
        transform: translateY(8%) scale(0.94);
      }
      #insights.open {
        transform: translateY(0) scale(1);
      }
      .insights__row {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }
      .insights__actions {
        justify-content: center;
      }
      .export {
        margin: 22px 0 8px;
      }
      .fab {
        width: 64px;
        height: 64px;
        font-size: 30px;
        right: var(--page-pad);
        bottom: calc(var(--page-pad) + var(--safe-bottom));
      }
    }

    header {
      grid-area: header;
      position: relative;
      inset: auto;
      z-index: 40;
      align-self: start;
      backdrop-filter: blur(22px) saturate(150%);
      background: var(--header-bg);
      border: 1px solid var(--header-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--header-shadow);
      overflow: hidden;
      isolation: isolate;
    }
    header.page-header::before {
      content: "";
      position: absolute;
      inset: -18% -22% -24%;
      border-radius: inherit;
      background: linear-gradient(
          135deg,
          rgba(115, 135, 215, 0.25) 0%,
          rgba(90, 183, 164, 0.22) 50%,
          rgba(115, 135, 215, 0.28) 100%
        );
      background-size: 220% 220%;
      opacity: 0.52;
      filter: blur(18px);
      animation: headerBreath 26s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    header.page-header::after {
      content: "";
      position: absolute;
      inset: -60% -40% auto -40%;
      height: clamp(160px, 28vw, 220px);
      background: radial-gradient(
        120% 140% at 50% 50%,
        rgba(115, 135, 215, 0.32),
        transparent 70%
      );
      opacity: 0.35;
      filter: blur(48px);
      pointer-events: none;
      mix-blend-mode: screen;
      animation: headerGlow 14s ease-in-out infinite alternate;
      z-index: 1;
    }
    header.page-header > * {
      position: relative;
      z-index: 2;
    }
    @keyframes headerBreath {
      0% {
        opacity: 0.42;
        background-position: 0% 40%;
        transform: scale(0.98);
      }
      50% {
        opacity: 0.72;
        background-position: 55% 100%;
        transform: scale(1.02);
      }
      100% {
        opacity: 0.45;
        background-position: 100% 40%;
        transform: scale(0.99);
      }
    }
    @keyframes headerGlow {
      0% {
        transform: translate3d(-12%, -8%, 0) scale(1);
        opacity: 0.28;
      }
      50% {
        transform: translate3d(6%, 6%, 0) scale(1.08);
        opacity: 0.45;
      }
      100% {
        transform: translate3d(16%, -6%, 0) scale(1.04);
        opacity: 0.32;
      }
    }
    @supports not ((backdrop-filter: blur(0)) or (-webkit-backdrop-filter: blur(0))) {
      header {
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        background: var(--surface-strong);
      }
      header.page-header::before {
        display: none;
        background: var(--surface-strong);
      }
    }
    .topbar {
      margin: 0;
      padding: clamp(18px, 3vw, 28px) clamp(18px, 3vw, 28px) clamp(14px, 2.5vw, 22px);
      display: grid;
      gap: clamp(12px, 2vw, 18px);
      position: relative;
      overflow: hidden;
      border-radius: inherit;
    }
    .topbar::after {
      content: "";
      position: absolute;
      inset: -40% -25% auto 42%;
      height: 160px;
      background: radial-gradient(
        120% 140% at 0% 50%,
        rgba(90, 183, 164, 0.32),
        transparent 68%
      );
      opacity: 0.7;
      filter: blur(34px);
      pointer-events: none;
      transform: translate3d(0, 0, 0);
    }
    .topbar > * {
      position: relative;
      z-index: 1;
    }
    .topbar__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      flex-wrap: wrap;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .brand img {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
    }
    .brand__text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      line-height: 1.1;
    }
    .brand__text strong {
      font-size: 1.05rem;
      letter-spacing: 0.2px;
    }
    .brand__text span {
      font-size: 0.75rem;
      color: var(--text-subtle);
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }
    .brand__text small {
      font-size: 0.7rem;
      color: var(--text-soft);
      letter-spacing: 0.36px;
      text-transform: uppercase;
    }
    .topbar__actions {
      display: flex;
      gap: 8px;
    }
    button {
      font-family: inherit;
      font-size: 0.95rem;
      border: none;
      cursor: pointer;
      background: none;
      color: inherit;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .icon-btn {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      color: var(--text);
      background: var(--header-icon-bg);
      border: 1px solid var(--header-icon-border);
      box-shadow: var(--header-icon-shadow);
    }
    .icon-btn:active {
      transform: translateY(1px) scale(0.98);
    }
    .link-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 0;
      background: none;
      border: none;
      color: var(--accent);
      font-weight: 600;
      font-size: 0.85rem;
      text-decoration: none;
      cursor: pointer;
    }
    .link-btn:hover {
      text-decoration: underline;
    }
    .link-btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      border-radius: 6px;
    }
    .chip-row {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 2px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .chip-row::-webkit-scrollbar {
      display: none;
    }
    .chip-row .chip {
      flex: 0 0 auto;
      padding: 8px 18px;
      border-radius: 999px;
      background: var(--chip-bg);
      border: 1px solid var(--chip-border);
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.1px;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      white-space: nowrap;
    }
    .chip-row .chip.active {
      background: var(--accent-soft);
      border-color: var(--chip-active-border);
      color: var(--text);
      box-shadow: var(--chip-active-shadow);
    }
    .utility {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .search {
      position: relative;
      flex: 1;
    }
    .search input {
      width: 100%;
      padding: 12px 44px 12px 16px;
      border-radius: 999px;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
      color: var(--text);
      font-size: 0.95rem;
      box-shadow: var(--field-shadow);
    }
    .search input::placeholder {
      color: var(--text-placeholder);
    }
    .search .ico {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.05rem;
      opacity: 0.7;
    }
    .smart-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--ghost-bg);
      border: 1px solid var(--ghost-border);
      color: var(--ghost-text);
      font-size: 0.85rem;
      font-weight: 600;
    }
    .smart-badge strong {
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 700;
    }
    .smart-badge button {
      background: transparent;
      border: none;
      color: var(--accent);
      font-weight: 600;
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0;
    }
    .smart-badge button:hover,
    .smart-badge button:focus-visible {
      text-decoration: underline;
    }
    .smart-badge button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      border-radius: 6px;
    }
    .smart-badge[hidden] {
      display: none;
    }

    .menu-overlay {
      position: fixed;
      inset: 0;
      background: rgba(3, 6, 17, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.24s ease;
      z-index: 75;
    }
    .menu-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }
    .command-menu {
      position: fixed;
      top: clamp(24px, 8vh, 64px);
      right: clamp(18px, 6vw, 48px);
      width: min(460px, calc(100% - 36px));
      max-height: calc(100vh - clamp(48px, 12vh, 96px));
      overflow: hidden auto;
      border-radius: 28px;
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0) 65%),
        var(--surface-strong);
      border: 1px solid var(--header-border);
      box-shadow: var(--shadow-lg);
      padding: clamp(20px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: clamp(18px, 3vw, 26px);
      transform: translateY(-14px) scale(0.94);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.24s ease, opacity 0.24s ease;
      z-index: 90;
    }
    .command-menu[aria-hidden="true"] {
      visibility: hidden;
    }
    .command-menu.open {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
      visibility: visible;
    }
    .command-menu__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
    }
    .command-menu__header h2 {
      margin: 4px 0;
      font-size: 1.45rem;
    }
    .command-menu__header p {
      margin: 0;
      color: var(--text-soft);
      font-size: 0.92rem;
      line-height: 1.45;
    }
    .command-menu__eyebrow {
      margin: 0 0 6px;
      font-size: 0.72rem;
      letter-spacing: 0.28em;
      text-transform: uppercase;
      color: var(--text-subtle);
    }
    .command-menu__close {
      flex-shrink: 0;
    }
    .command-menu__section {
      display: grid;
      gap: 14px;
    }
    .command-menu__section-title {
      font-size: 0.75rem;
      letter-spacing: 0.32em;
      text-transform: uppercase;
      color: var(--text-subtle);
    }
    .command-menu__section-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .command-menu__stats {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .command-menu__stat {
      padding: 14px 16px;
      border-radius: var(--radius-md);
      border: 1px solid var(--ghost-border);
      background: var(--ghost-bg);
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 110px;
    }
    .command-menu__stat span {
      font-size: 0.75rem;
      letter-spacing: 0.32px;
      text-transform: uppercase;
      color: var(--text-subtle);
    }
    .command-menu__stat strong {
      font-size: 1.6rem;
      font-weight: 700;
    }
    .command-menu__stat[data-kind="wait"] strong {
      color: var(--accent);
    }
    .command-menu__stat[data-kind="pause"] strong {
      color: var(--warn);
    }
    .command-menu__stat[data-kind="done"] strong {
      color: var(--ok);
    }
    .command-menu__stat[data-kind="produced"] strong {
      color: var(--accent-2);
    }
    .command-menu__stat small {
      font-size: 0.78rem;
      color: var(--text-soft);
    }
    .command-menu__progress {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }
    .command-menu__progress-labels {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .command-menu__progress-bar {
      grid-column: 1 / -1;
      height: 8px;
      border-radius: 999px;
      background: var(--insight-progress-bg);
      position: relative;
      overflow: hidden;
    }
    .command-menu__progress-bar span {
      position: absolute;
      inset: 0;
      width: 0;
      background: var(--brand-gradient);
      border-radius: inherit;
      box-shadow: 0 8px 18px rgba(90, 183, 164, 0.32);
      transition: width 0.25s ease;
    }
    .command-menu__progress-value {
      font-weight: 700;
      font-size: 1rem;
      justify-self: end;
    }
    .smart-filter__info {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      align-items: center;
      font-size: 0.85rem;
      color: var(--text-soft);
    }
    .smart-filter__count strong {
      font-size: 1rem;
      color: var(--text);
    }
    .command-menu__smart-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    .command-menu__smart {
      padding: 14px 16px;
      border-radius: var(--radius-md);
      border: 1px solid var(--ghost-border);
      background: var(--ghost-bg);
      color: var(--text-soft);
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .command-menu__smart:hover {
      border-color: var(--ghost-hover-border);
      background: var(--ghost-hover-bg);
      color: var(--text);
    }
    .command-menu__smart-label {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text);
    }
    .command-menu__smart small {
      font-size: 0.8rem;
      color: var(--text-muted);
    }
    .command-menu__smart.is-active {
      background: var(--brand-gradient);
      border-color: transparent;
      color: var(--btn-text);
      box-shadow: 0 16px 34px rgba(8, 16, 30, 0.45);
    }
    .command-menu__smart.is-active .command-menu__smart-label {
      color: var(--btn-text);
    }
    .command-menu__smart.is-active small {
      color: rgba(7, 18, 31, 0.72);
    }
    .command-menu__toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .command-menu__toggle {
      flex: 1 1 160px;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      border: 1px solid var(--control-border);
      background: var(--control-bg);
      color: var(--text-muted);
      font-weight: 600;
      text-align: left;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .command-menu__toggle:hover {
      border-color: var(--ghost-hover-border);
      background: var(--ghost-hover-bg);
      color: var(--text);
    }
    .command-menu__toggle.is-active {
      background: var(--brand-gradient);
      border-color: transparent;
      color: var(--btn-text);
      box-shadow: 0 14px 30px rgba(8, 16, 30, 0.4);
    }
    .command-menu__actions {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    .command-menu__action {
      position: relative;
      display: grid;
      gap: 6px;
      padding: 18px;
      border-radius: var(--radius-md);
      border: 1px solid var(--ghost-border);
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0) 100%),
        var(--surface-soft);
      color: var(--text);
      text-align: left;
      overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .command-menu__action:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      border-color: var(--ghost-hover-border);
    }
    .command-menu__action strong {
      font-size: 1rem;
    }
    .command-menu__action span {
      font-size: 0.82rem;
      color: var(--text-soft);
    }
    .command-menu__icon {
      width: 40px;
      height: 40px;
      border-radius: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      background: var(--ghost-bg);
      border: 1px solid var(--ghost-border);
      color: var(--ghost-text);
    }
    body.menu-open {
      overflow: hidden;
    }
    @media (max-width: 720px) {
      .command-menu {
        left: 50%;
        right: auto;
        top: clamp(16px, 8vh, 40px);
        width: min(520px, calc(100% - 32px));
        transform: translate(-50%, -18px) scale(0.92);
      }
      .command-menu.open {
        transform: translate(-50%, 0) scale(1);
      }
      .command-menu__stats {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
      .command-menu__actions {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
    }

    #insights {
      grid-area: insights;
      position: fixed;
      top: calc(var(--page-pad) + 72px);
      left: 50%;
      width: min(420px, calc(100% - 2 * var(--page-pad)));
      padding: 20px clamp(18px, 3vw, 24px) 24px;
      border-radius: var(--radius-lg);
      background: var(--insight-bg);
      border: 1px solid var(--insight-border);
      box-shadow: var(--shadow-lg);
      transform-origin: top center;
      transform: translate(-50%, -6%) scale(0.92);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.22s ease, transform 0.22s ease;
      z-index: 70;
      max-height: calc(100vh - 2 * var(--page-pad));
      overflow: auto;
    }
    #insights.open {
      opacity: 1;
      transform: translate(-50%, 0) scale(1);
      pointer-events: auto;
    }
    .insights__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 12px;
    }
    .insights__head strong {
      font-size: 0.95rem;
      letter-spacing: 0.3px;
    }
    .insights__row {
      display: grid;
      gap: clamp(12px, 2vw, 18px);
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .insight-card {
      padding: 14px 16px 16px;
      border-radius: var(--radius-md);
      background: var(--insight-card-bg);
      border: 1px solid var(--insight-card-border);
      box-shadow: var(--insight-card-shadow);
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
    }
    .insight-card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--insight-card-highlight);
      opacity: 0.4;
      pointer-events: none;
    }
    .insight-card span {
      font-size: 0.75rem;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .insight-card strong {
      font-size: 1.7rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 6px 18px rgba(90, 183, 164, 0.32);
    }
    .insight-card small {
      font-size: 0.8rem;
      color: var(--text-subtle);
      line-height: 1.3;
    }
    .insight-card--wide {
      grid-column: span 2;
    }
    @media (max-width: 520px) {
      .insight-card--wide {
        grid-column: span 1;
      }
    }
    .insight-progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: var(--insight-progress-bg);
      overflow: hidden;
      position: relative;
    }
    .insight-progress__bar {
      position: absolute;
      inset: 0;
      width: 0;
      background: var(--brand-gradient);
      border-radius: inherit;
      box-shadow: 0 4px 12px rgba(90, 183, 164, 0.28);
      transition: width 0.25s ease;
    }
    .insights__actions {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .ghost-small {
      background: var(--ghost-bg);
      border: 1px dashed var(--ghost-border);
      color: var(--ghost-text);
      border-radius: 999px;
      padding: 8px 14px;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
    }
    .ghost-small:hover {
      background: var(--ghost-hover-bg);
      border-color: var(--ghost-hover-border);
      color: var(--ghost-hover-text);
    }

    #list {
      margin-top: 0;
      display: grid;
      gap: clamp(12px, 2vw, 18px);
    }
    .card {
      position: relative;
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      border: 1px solid var(--card-border);
      padding: 18px 18px 16px;
      box-shadow: var(--shadow-md);
      backdrop-filter: blur(2px);
      animation: cardFade 0.3s ease both;
      overflow: hidden;
      --card-flash: rgba(115, 135, 215, 0.32);
    }
    .card[data-status="pause"] {
      --card-flash: rgba(242, 179, 106, 0.32);
    }
    .card[data-status="done"] {
      --card-flash: rgba(90, 183, 164, 0.32);
    }
    .card::before {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      background: radial-gradient(120% 140% at 50% 45%, var(--card-flash), transparent 72%);
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      transition: opacity 0.3s ease;
    }
    .card::after {
      content: "";
      position: absolute;
      inset: -16px;
      border-radius: inherit;
      background: radial-gradient(120% 140% at 50% 40%, rgba(115, 135, 215, 0.35), transparent 70%);
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .card.card--enter {
      animation: cardSlideGlow 0.65s cubic-bezier(0.22, 1, 0.36, 1) both;
    }
    .card.card--enter::after {
      animation: cardHalo 0.65s ease-out forwards;
    }
    .card--status-flash::before {
      animation: cardStatusFlash 0.6s ease-out forwards;
    }
    @keyframes cardFade {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: none;
      }
    }
    @keyframes cardSlideGlow {
      0% {
        opacity: 0;
        transform: translateY(24px);
        box-shadow: 0 18px 42px rgba(90, 183, 164, 0.2);
      }
      55% {
        opacity: 1;
        transform: translateY(-4px);
        box-shadow: 0 22px 48px rgba(90, 183, 164, 0.28);
      }
      100% {
        opacity: 1;
        transform: none;
        box-shadow: var(--shadow-md);
      }
    }
    @keyframes cardHalo {
      0% {
        opacity: 0.75;
        transform: scale(0.92);
      }
      60% {
        opacity: 0.35;
        transform: scale(1.04);
      }
      100% {
        opacity: 0;
        transform: scale(1.08);
      }
    }
    @keyframes cardStatusFlash {
      0% {
        opacity: 0.5;
        transform: scale(0.96);
      }
      60% {
        opacity: 0.2;
        transform: scale(1.02);
      }
      100% {
        opacity: 0;
        transform: scale(1.05);
      }
    }
    .row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .handle {
      cursor: grab;
      user-select: none;
      color: var(--text-faint);
      font-size: 1.2rem;
    }
    .title {
      flex: 1;
      min-width: 0;
      font-weight: 700;
      font-size: 1rem;
      letter-spacing: 0.15px;
    }
    .title span {
      display: block;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    .badge {
      --badge-halo: rgba(115, 135, 215, 0.35);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      background: var(--badge-bg);
      border: 1px solid var(--badge-border);
      color: var(--badge-text);
      box-shadow: none;
      transition: background 0.25s ease, border-color 0.25s ease, color 0.25s ease,
        box-shadow 0.4s ease;
    }
    .badge[data-s="pause"] {
      --badge-halo: rgba(242, 179, 106, 0.45);
      background: var(--badge-pause-bg);
      border-color: var(--badge-pause-border);
      color: var(--badge-pause-text);
    }
    .badge[data-s="done"] {
      --badge-halo: rgba(90, 183, 164, 0.45);
      background: var(--badge-done-bg);
      border-color: var(--badge-done-border);
      color: var(--badge-done-text);
    }
    .badge--pulse {
      animation: badgePulse 0.7s ease-out;
    }
    @keyframes badgePulse {
      0% {
        box-shadow: 0 0 0 0 var(--badge-halo);
      }
      65% {
        box-shadow: 0 0 0 10px rgba(0, 0, 0, 0);
      }
      100% {
        box-shadow: 0 0 0 14px rgba(0, 0, 0, 0);
      }
    }
    .meta {
      margin-top: 10px;
      color: var(--text-muted);
      font-size: 0.82rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px 14px;
      word-break: break-word;
    }
    .meta b {
      color: var(--text);
    }
    .note {
      margin-top: 10px;
      font-size: 0.84rem;
      color: var(--note-text);
      background: var(--note-bg);
      border: 1px dashed var(--note-border);
      padding: 10px 12px;
      border-radius: var(--radius-sm);
    }
    .actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--touch), 1fr));
      gap: 10px;
      margin-top: 14px;
    }
    .btn {
      min-height: var(--touch);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0;
      border-radius: var(--radius-sm);
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-text);
      line-height: 1;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 22px rgba(5, 12, 26, 0.35);
    }
    .btn svg {
      width: 22px;
      height: 22px;
      display: block;
      pointer-events: none;
    }
    .btn[data-a="pause"] {
      background: var(--btn-pause-bg);
      color: var(--btn-pause-text);
      border-color: var(--btn-pause-border);
    }
    .btn[data-a="done"] {
      background: var(--btn-done-bg);
      color: var(--btn-done-text);
      border-color: var(--btn-done-border);
    }
    .btn[data-a="del"] {
      background: var(--btn-del-bg);
      color: var(--btn-del-text);
      border-color: var(--btn-del-border);
    }
    .awaiting-long {
      border-color: rgba(115, 135, 215, 0.5);
      box-shadow: 0 0 0 1px rgba(115, 135, 215, 0.42) inset, var(--shadow-md);
    }

    .empty-state {
      margin-top: 30px;
      padding: 26px;
      border-radius: var(--radius-lg);
      border: 1px dashed var(--border-subtle);
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
      text-align: center;
      color: var(--text-muted);
      line-height: 1.5;
      box-shadow: 0 16px 28px rgba(6, 12, 26, 0.35);
    }
    .empty-state strong {
      display: block;
      font-size: 1.05rem;
      margin-bottom: 6px;
      color: var(--text);
    }

    .export {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 18px 0;
    }
    .pill {
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
      color: var(--text);
      border-radius: 999px;
      padding: 10px 20px;
      font-weight: 700;
      letter-spacing: 0.2px;
      box-shadow: 0 12px 26px rgba(5, 10, 24, 0.35);
    }

    .fab {
      position: fixed;
      right: max(20px, var(--page-pad));
      bottom: calc(var(--page-pad) + var(--safe-bottom));
      width: 68px;
      height: 68px;
      border-radius: 50%;
      background: var(--brand-gradient);
      color: #07121f;
      border: none;
      box-shadow: 0 26px 48px rgba(8, 16, 30, 0.6);
      font-size: 34px;
    }
    .fab:active {
      transform: scale(0.96);
    }

    .sheet,
    .settings {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -100%;
      background: var(--surface-strong);
      border-top-left-radius: 26px;
      border-top-right-radius: 26px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 -28px 40px rgba(0, 0, 0, 0.55);
      padding: 18px 18px calc(28px + var(--safe-bottom));
      transition: bottom 0.28s ease;
      z-index: 80;
      max-width: 520px;
      margin: 0 auto;
    }
    .sheet.open,
    .settings.open {
      bottom: 0;
    }
    .sheet h3,
    .settings h3 {
      margin: 4px 4px 14px;
      font-size: 1.05rem;
    }
    .f {
      display: grid;
      gap: 10px;
    }
    .f input,
    .f select,
    .f textarea {
      width: 100%;
      min-height: 52px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--input-text);
      padding: 12px 14px;
      font-size: 1rem;
      outline: none;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    .f textarea {
      min-height: 90px;
      resize: vertical;
    }
    .f input:focus,
    .f select:focus,
    .f textarea:focus {
      border-color: var(--input-focus-border);
      box-shadow: 0 0 0 2px var(--input-focus-ring);
    }
    .row2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .cta {
      display: flex;
      gap: 10px;
      margin-top: 12px;
    }
    .ghost {
      background: var(--ghost-bg);
      border: 1px dashed var(--ghost-border);
      color: var(--ghost-text);
      transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
    }
    .ghost:hover {
      background: var(--ghost-hover-bg);
      border-color: var(--ghost-hover-border);
      color: var(--ghost-hover-text);
    }
    .theme-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .theme-grid .ghost-small.active {
      background: var(--ghost-active-bg);
      border-color: var(--ghost-active-border);
      color: var(--ghost-active-text);
    }

    body.dense .card {
      padding: 12px 14px;
    }
    body.dense .btn {
      min-height: 44px;
    }
    body.dense .actions {
      gap: 8px;
    }
    body.dense .search input {
      padding: 10px 40px 10px 14px;
    }

    .confetti {
      position: fixed;
      pointer-events: none;
      inset: 0;
      z-index: 90;
    }

    @media (min-width: 600px) {
      .sheet,
      .settings {
        border-radius: 26px;
      }
    }

    @media (min-width: 768px) {
      .page-grid {
        grid-template-columns: minmax(0, 1.1fr) minmax(280px, 0.9fr);
        grid-template-areas:
          "header header"
          "list insights";
      }
      header {
        position: sticky;
        top: var(--page-pad);
      }
      #insights {
        position: sticky;
        top: var(--page-pad);
        left: auto;
        width: 100%;
        max-height: none;
        transform: none;
        opacity: 1;
        pointer-events: auto;
        box-shadow: var(--shadow-lg);
        overflow: visible;
        align-self: start;
      }
      #insights.open {
        transform: none;
      }
      .insights__actions {
        justify-content: flex-start;
      }
      #insightToggle {
        display: none;
      }
      #closeInsights {
        display: none;
      }
      .page-main {
        padding-bottom: clamp(160px, 18vh, 220px);
      }
      #list {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }
    }

    @media (min-width: 1280px) {
      .page-grid {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(320px, 0.85fr);
        grid-template-areas:
          "header header insights"
          "list list insights";
      }
      .insights__row {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
      .insight-card--wide {
        grid-column: span 2;
      }
      #list {
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      }
    }

  </style>
</head>
<body>
  <div class="page-grid">
    <header class="page-header">
    <div class="topbar">
      <div class="topbar__head">
        <div class="brand">
          <img
            src="https://djuqbvg97u5zb.cloudfront.net/vmachonpr/images/websitelogos/retailer_site_logo88.png"
            alt="V‑MACH"
          />
          <div class="brand__text">
            <strong>Production badges</strong>
            <span>V‑MACH</span>
            <small>Suivi temps réel des commandes</small>
          </div>
        </div>
        <div class="topbar__actions">
          <button
            id="menuBtn"
            class="icon-btn"
            type="button"
            aria-expanded="false"
            aria-controls="commandMenu"
            aria-label="Menu principal"
            title="Menu principal"
          >
            ☰
          </button>
          <button
            id="insightToggle"
            class="icon-btn"
            type="button"
            aria-expanded="false"
            aria-controls="insights"
            title="Afficher les compteurs"
          >
            📊
          </button>
          <button id="settingsBtn" class="icon-btn" type="button" title="Réglages">⚙️</button>
        </div>
      </div>
      <div class="chip-row" id="filters">
        <button class="chip active" data-f="all">Toutes</button>
        <button class="chip" data-f="wait">En attente</button>
        <button class="chip" data-f="pause">En pause</button>
        <button class="chip" data-f="done">Terminées</button>
      </div>
      <div class="utility">
        <div class="search">
          <input
            id="q"
            type="search"
            placeholder="Recherche rapide (client, badge, format…)"
          />
          <span class="ico">🔎</span>
        </div>
        <div class="smart-badge" id="smartFilterBadge" hidden role="status" aria-live="polite">
          <span>Vue intelligente&nbsp;:</span>
          <strong id="smartFilterBadgeLabel"></strong>
          <button type="button" data-smart-reset title="Réinitialiser la vue intelligente">
            Réinitialiser
          </button>
        </div>
      </div>
    </div>
    </header>

    <div class="menu-overlay" id="menuOverlay" hidden></div>
    <nav class="command-menu" id="commandMenu" aria-hidden="true" tabindex="-1">
      <header class="command-menu__header">
        <div>
          <p class="command-menu__eyebrow">Centre de contrôle</p>
          <h2>Menu principal</h2>
          <p>Accédez rapidement aux actions clés et à vos vues personnalisées.</p>
        </div>
        <button class="icon-btn command-menu__close" id="closeMenu" type="button" title="Fermer le menu">✕</button>
      </header>

      <section class="command-menu__section">
        <span class="command-menu__section-title">Résumé en direct</span>
        <div class="command-menu__stats">
          <div class="command-menu__stat" data-kind="total">
            <span>Total suivi</span>
            <strong id="menuCountTotal">0</strong>
            <small>Commandes actives</small>
          </div>
          <div class="command-menu__stat" data-kind="wait">
            <span>En attente</span>
            <strong id="menuCountWait">0</strong>
            <small>À lancer</small>
          </div>
          <div class="command-menu__stat" data-kind="pause">
            <span>En pause</span>
            <strong id="menuCountPause">0</strong>
            <small>Temporisées</small>
          </div>
          <div class="command-menu__stat" data-kind="done">
            <span>Terminées</span>
            <strong id="menuCountDone">0</strong>
            <small>Clôturées</small>
          </div>
          <div class="command-menu__stat" data-kind="produced">
            <span>Badges produits</span>
            <strong id="menuProduced">0</strong>
            <small>Total cumulé</small>
          </div>
        </div>
        <div class="command-menu__progress">
          <div class="command-menu__progress-labels">
            <span>Progression globale</span>
            <small id="menuCompletionSummary">0 / 0 commande</small>
          </div>
          <div class="command-menu__progress-bar" role="presentation">
            <span id="menuCompletionBar"></span>
          </div>
          <span class="command-menu__progress-value" id="menuCompletionLabel">0 %</span>
        </div>
      </section>

      <section class="command-menu__section">
        <div class="command-menu__section-head">
          <span class="command-menu__section-title">Vues intelligentes</span>
          <button class="link-btn" type="button" data-smart-reset>Réinitialiser</button>
        </div>
        <p class="smart-filter__info">
          <span id="smartFilterSummary">Toutes les commandes selon vos filtres.</span>
          <span class="smart-filter__count"><strong id="smartFilterCount">0</strong> commande(s) visibles</span>
        </p>
        <div class="command-menu__smart-grid">
          <button class="command-menu__smart" type="button" data-smart="default">
            <span class="command-menu__smart-label">Vue standard</span>
            <small>Respecte vos filtres et tris.</small>
          </button>
          <button class="command-menu__smart" type="button" data-smart="urgent">
            <span class="command-menu__smart-label">Urgences</span>
            <small>Commandes en attente depuis 90&nbsp;min+</small>
          </button>
          <button class="command-menu__smart" type="button" data-smart="highVolume">
            <span class="command-menu__smart-label">Gros volumes</span>
            <small>200 pièces et plus.</small>
          </button>
          <button class="command-menu__smart" type="button" data-smart="recentDone">
            <span class="command-menu__smart-label">Terminées 24&nbsp;h</span>
            <small>Clôturées ces dernières 24&nbsp;h.</small>
          </button>
        </div>
      </section>

      <section class="command-menu__section">
        <span class="command-menu__section-title">Trier &amp; afficher</span>
        <div class="command-menu__toggles">
          <button class="command-menu__toggle" type="button" data-sort="recent">Plus récents</button>
          <button class="command-menu__toggle" type="button" data-sort="oldest">Plus anciens</button>
          <button class="command-menu__toggle" type="button" data-sort="qty">Gros volumes</button>
          <button class="command-menu__toggle" type="button" data-sort="status">Par statut</button>
        </div>
        <div class="command-menu__toggles">
          <button class="command-menu__toggle" type="button" data-theme-toggle="light">☀️ Thème clair</button>
          <button class="command-menu__toggle" type="button" data-theme-toggle="dark">🌙 Thème sombre</button>
          <button class="command-menu__toggle" type="button" data-preference-toggle="dense">🧱 Mode compact</button>
        </div>
      </section>

      <section class="command-menu__section">
        <span class="command-menu__section-title">Actions rapides</span>
        <div class="command-menu__actions">
          <button class="command-menu__action" type="button" data-menu-action="new">
            <span class="command-menu__icon">＋</span>
            <strong>Nouvelle commande</strong>
            <span>Créez un badge immédiatement.</span>
          </button>
          <button class="command-menu__action" type="button" data-menu-action="open-insights">
            <span class="command-menu__icon">📊</span>
            <strong>Compteurs</strong>
            <span>Ouvrir la synthèse des performances.</span>
          </button>
          <button class="command-menu__action" type="button" data-menu-action="open-settings">
            <span class="command-menu__icon">⚙️</span>
            <strong>Réglages</strong>
            <span>Personnalisez l'expérience.</span>
          </button>
          <button class="command-menu__action" type="button" data-menu-action="export-email">
            <span class="command-menu__icon">✉️</span>
            <strong>Export e‑mail</strong>
            <span>Préparez un récapitulatif à partager.</span>
          </button>
        </div>
      </section>
    </nav>

    <aside id="insights" class="insights-panel" aria-hidden="true">
      <div class="insights__head">
        <strong>Compteurs</strong>
        <button class="ghost-small" id="closeInsights" type="button" title="Fermer les compteurs">✕</button>
      </div>
      <div class="insights__row">
        <div class="insight-card">
          <span>Badges fabriqués</span>
          <strong id="insightBadges">0</strong>
          <small>Depuis la dernière remise à zéro</small>
        </div>
        <div class="insight-card">
          <span>Total commandes</span>
          <strong id="insightOrders">0</strong>
          <small>Commandes enregistrées</small>
        </div>
        <div class="insight-card">
          <span>En cours</span>
          <strong id="insightWaiting">0</strong>
          <small>Commandes actives</small>
        </div>
        <div class="insight-card">
          <span>En pause</span>
          <strong id="insightPaused">0</strong>
          <small>Temporisées</small>
        </div>
        <div class="insight-card insight-card--wide">
          <span>Durée moyenne (terminées)</span>
          <strong id="insightAvg">—</strong>
          <small id="insightAvgDetail">Aucune commande terminée</small>
        </div>
        <div class="insight-card insight-card--wide">
          <span>Temps actif cumulé</span>
          <strong id="insightActive">—</strong>
          <div class="insight-progress" aria-hidden="true">
            <div class="insight-progress__bar" id="insightCompletionBar"></div>
          </div>
          <small>
            <b id="insightDoneCount">0</b> terminées • <span id="insightCompletionLabel">0%</span> de progression
          </small>
        </div>
      </div>
      <div class="insights__actions">
        <button class="ghost-small" id="resetInsights" type="button" title="Réinitialiser les compteurs">
          Réinitialiser
        </button>
      </div>
    </aside>

    <main class="page-main">
      <div id="emptyState" class="empty-state" hidden>
        <strong>Aucune commande</strong>
        Ajoutez votre première commande pour démarrer la production.
      </div>
      <div id="list"></div>

      <div class="export">
        <button class="pill" id="importCsv">Importer CSV</button>
        <input class="sr-only" type="file" id="importCsvInput" accept=".csv,text/csv" />
        <button class="pill" id="exportCsv">Export CSV</button>
        <button class="pill" id="exportEmail">Export E‑mail</button>
      </div>
    </main>
  </div>

  <button class="fab" id="fab" title="Ajouter">＋</button>
  <canvas class="confetti" id="confetti" width="0" height="0" hidden></canvas>

  <!-- Add/Edit Sheet -->
  <div class="sheet" id="sheet" aria-hidden="true">
    <h3 id="sheetTitle">Nouvelle commande</h3>
    <form class="f" id="orderForm">
      <label class="sr-only" for="fClient">Client *</label>
      <input
        id="fClient"
        name="fClient"
        placeholder="Client *"
        required
        list="clientHistory"
        autocomplete="off"
      />
      <datalist id="clientHistory"></datalist>
      <label class="sr-only" for="fName">Nom du badge *</label>
      <input
        id="fName"
        name="fName"
        placeholder="Nom du badge *"
        required
        list="nameHistory"
        autocomplete="off"
      />
      <datalist id="nameHistory"></datalist>
      <div class="row2">
        <div>
          <label class="sr-only" for="fQty">Quantité *</label>
          <input
            id="fQty"
            name="fQty"
            type="number"
            min="1"
            placeholder="Quantité *"
            required
          />
        </div>
        <div>
          <label class="sr-only" for="fDiam">Diamètre / format *</label>
          <select id="fDiam" name="fDiam" required>
            <option value="">Diamètre / format *</option>
            <option>28 mm</option>
            <option>38 mm</option>
            <option>45 mm</option>
            <option>58 mm</option>
            <option>89 mm</option>
            <option>Rect. 80 × 50 mm</option>
          </select>
        </div>
      </div>
      <div class="row2">
        <div>
          <label class="sr-only" for="fFinish">Finition *</label>
          <select id="fFinish" name="fFinish" required>
            <option value="">Finition *</option>
            <option>Mat</option>
            <option>Brillant</option>
          </select>
        </div>
        <div>
          <label class="sr-only" for="fType">Attache *</label>
          <select id="fType" name="fType" required>
            <option value="">Attache *</option>
            <option>Épingle</option>
            <option>Aimant décoratif</option>
            <option>Magnétique textile</option>
            <option>Miroir</option>
            <option>Décapsuleur magnet</option>
          </select>
        </div>
      </div>
      <div class="row2">
        <div>
          <label class="sr-only" for="fCarton">Carton *</label>
          <select id="fCarton" name="fCarton" required>
            <option value="">Carton *</option>
            <option>Boîte A11</option>
            <option>Boîte A12</option>
            <option>Boîte A14</option>
            <option>Petite boîte</option>
          </select>
        </div>
        <div>
          <label class="sr-only" for="fStatus">Statut</label>
          <select id="fStatus" name="fStatus">
            <option value="wait">En attente</option>
            <option value="pause">En pause</option>
            <option value="done">Terminée</option>
          </select>
        </div>
      </div>
      <label class="sr-only" for="fNote">Note (optionnel)</label>
      <textarea id="fNote" name="fNote" placeholder="Note (optionnel)"></textarea>
      <div class="cta">
        <button class="btn ghost" id="cancelBtn" type="button">Annuler</button>
        <button
          class="btn"
          id="saveBtn"
          style="background: var(--brand-gradient); color: #111; border: 0"
          type="submit"
        >
          Enregistrer
        </button>
      </div>
    </form>
  </div>

  <!-- Settings sheet -->
  <div class="settings" id="settings" aria-hidden="true">
    <h3>Réglages</h3>
    <div class="f">
      <label class="ghost"
        ><input
          type="checkbox"
          id="optDur"
          style="transform: scale(1.2); margin-right: 8px; vertical-align: middle"
        />
        Inclure la durée dans l'export e‑mail</label
      >
      <label class="ghost"
        ><input
          type="checkbox"
          id="optHaptic"
          style="transform: scale(1.2); margin-right: 8px; vertical-align: middle"
          checked
        />
        Vibrations (retour haptique)</label
      >
      <label class="ghost"
        ><input
          type="checkbox"
          id="optDense"
          style="transform: scale(1.2); margin-right: 8px; vertical-align: middle"
        />
        Mode compact (dense)</label
      >

      <h4 style="margin: 8px 2px">Thème</h4>
      <div class="theme-grid" id="themes">
        <button class="ghost-small" data-theme="light" title="Light">Light</button>
        <button class="ghost-small" data-theme="dark" title="Dark">Dark</button>
      </div>

      <div class="cta">
        <button class="btn ghost" id="closeSettings">Fermer</button>
        <button class="btn" id="clearAll" style="background: var(--danger); color: #fff; border: 0">
          Tout effacer
        </button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script type="module" src="./parse-batch-csv.js"></script>
  <script>
    /* ====== State & Utils ====== */
    const K = "vmach_badges_v1";
    const P = "vmach_prefs_v1";
    const THEME = "vmach_theme";
    const STATS_BASE = "vmach_stats_baseline_v1";
    const DEFAULT_THEME = "dark";
    const LAST_FORM = "vmach_last_form_v1";
    const FORM_HISTORY = "vmach_form_history_v1";
    const HISTORY_LIMIT = 120;
    const SMART_FILTER_KEY = "vmach_smart_filter_v1";
    const SMART_FILTERS = {
      default: {
        id: "default",
        label: "Vue standard",
        description: "Affiche toutes les commandes selon vos filtres et votre tri.",
      },
      urgent: {
        id: "urgent",
        label: "Urgences",
        description: "Met en avant les commandes en attente depuis plus de 90 minutes.",
      },
      highVolume: {
        id: "highVolume",
        label: "Gros volumes",
        description: "Filtre les commandes de 200 badges et plus.",
      },
      recentDone: {
        id: "recentDone",
        label: "Terminées 24 h",
        description: "Affiche les commandes clôturées sur les dernières 24 heures.",
      },
    };
    const URGENT_DELAY_MS = 90 * 60 * 1000;
    const RECENT_DONE_MS = 24 * 60 * 60 * 1000;
    const HIGH_VOLUME_QTY = 200;
    const ICONS = {
      edit: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4Z"></path></svg>',
      pause: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16" rx="1"></rect><rect x="14" y="4" width="4" height="16" rx="1"></rect></svg>',
      play: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><polygon points="7 4 19 12 7 20 7 4"></polygon></svg>',
      check: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 10 16 4 11"></polyline></svg>',
      refresh: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 4 20 9 15 9"></polyline><polyline points="4 20 4 15 9 15"></polyline><path d="M5.6 9A7 7 0 0 1 19 9"></path><path d="M19 15a7 7 0 0 1-13.4 1"></path></svg>',
      trash: '<svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>',
    };

    Object.keys(ICONS).forEach((key) => {
      ICONS[key] = ICONS[key].trim();
    });

    function isValidTheme(value) {
      return value === "light" || value === "dark";
    }

    function resolveTheme(value) {
      return isValidTheme(value) ? value : DEFAULT_THEME;
    }

    function resolveSmartFilter(value) {
      return SMART_FILTERS[value] ? value : "default";
    }

    function getSmartFilterConfig(value) {
      return SMART_FILTERS[value] || SMART_FILTERS.default;
    }

    let items = load();
    let statsBaseline = loadStatsBaseline();
    let lastStats = {
      produced: 0,
      totalOrders: 0,
      waiting: 0,
      paused: 0,
      avgDurationSec: 0,
      activeSec: 0,
      completion: 0,
      doneCount: 0,
    };
    let lastFormValues = loadLastFormValues();
    let formHistory = loadFormHistory();
    let filter = "all",
      search = "";
    let sortBy = localStorage.getItem("vmach_sort") || "recent";
    let editId = null;
    let liveTimer = null; // global unique (fix redeclaration)
    let smartFilter = resolveSmartFilter(localStorage.getItem(SMART_FILTER_KEY));
    if (smartFilter === "recentDone") {
      filter = "done";
    } else if ((smartFilter === "urgent" || smartFilter === "highVolume") && filter === "done") {
      filter = "all";
    }
    let filterBeforeSmart = filter;

    localStorage.setItem(SMART_FILTER_KEY, smartFilter);

    items = items.map(enrichItemState);

    const $ = (sel) => document.querySelector(sel);
    const listEl = $("#list");
    const clientHistoryList = $("#clientHistory");
    const nameHistoryList = $("#nameHistory");

    const emptyStateEl = $("#emptyState");

    seedFormHistoryFromItems(items);


    let sortableInstance = null;
    let swipeStartX = 0;
    let swipeStartY = 0;
    let swipeIsHorizontal = false;
    let swipeMoving = false;
    let swipeCard = null;

    const DB_NAME = "vmach_badges_db";
    const DB_STORE = "state";
    const DB_VERSION = 1;
    let dbPromise = null;

    function load() {
      try {
        const d = JSON.parse(localStorage.getItem(K));
        return Array.isArray(d) ? d : [];
      } catch {
        return [];
      }
    }
    function save() {
      localStorage.setItem(K, JSON.stringify(items));
      saveToIndexedDB(items);

    }

    function loadLastFormValues() {
      try {
        const raw = JSON.parse(localStorage.getItem(LAST_FORM) || "{}");
        if (raw && typeof raw === "object") {
          return {
            qty:
              typeof raw.qty === "string"
                ? raw.qty
                : raw.qty || raw.qty === 0
                ? String(raw.qty)
                : "",
            diam: typeof raw.diam === "string" ? raw.diam : "",
            finish: typeof raw.finish === "string" ? raw.finish : "",
            type: typeof raw.type === "string" ? raw.type : "",
            carton: typeof raw.carton === "string" ? raw.carton : "",
          };
        }
      } catch (err) {
        console.warn("Impossible de lire les dernières valeurs du formulaire", err);
      }
      return { qty: "", diam: "", finish: "", type: "", carton: "" };
    }

    function persistLastFormValues() {
      try {
        localStorage.setItem(LAST_FORM, JSON.stringify(lastFormValues));
      } catch (err) {
        console.warn("Impossible de sauvegarder les dernières valeurs du formulaire", err);
      }
    }

    function rememberLastFormValues(fields) {
      if (!fields) return;
      lastFormValues = {
        qty: fields.fQty?.value ? String(fields.fQty.value) : "",
        diam: fields.fDiam?.value || "",
        finish: fields.fFinish?.value || "",
        type: fields.fType?.value || "",
        carton: fields.fCarton?.value || "",
      };
      persistLastFormValues();
    }

    function hasSelectOption(select, value) {
      if (!select || !value) return false;
      return Array.from(select.options || []).some((opt) => opt.value === value);
    }

    function applyLastFormValues(fields) {
      if (!fields || !lastFormValues) return;
      if (fields.fQty && lastFormValues.qty) fields.fQty.value = lastFormValues.qty;
      if (fields.fDiam && hasSelectOption(fields.fDiam, lastFormValues.diam)) {
        fields.fDiam.value = lastFormValues.diam;
      }
      if (fields.fFinish && hasSelectOption(fields.fFinish, lastFormValues.finish)) {
        fields.fFinish.value = lastFormValues.finish;
      }
      if (fields.fType && hasSelectOption(fields.fType, lastFormValues.type)) {
        fields.fType.value = lastFormValues.type;
      }
      if (fields.fCarton && hasSelectOption(fields.fCarton, lastFormValues.carton)) {
        fields.fCarton.value = lastFormValues.carton;
      }
    }

    function normalizeHistoryValue(value) {
      return typeof value === "string" ? value.trim() : "";
    }

    function historyKey(value) {
      const normalized = normalizeHistoryValue(value);
      return normalized ? normalized.toLocaleLowerCase("fr-FR") : "";
    }

    function makeComboKey(client, name) {
      const c = historyKey(client);
      const n = historyKey(name);
      if (!c || !n) return "";
      return `${c}__${n}`;
    }

    function trimHistoryList(list, max = HISTORY_LIMIT) {
      if (!Array.isArray(list)) return;
      if (list.length > max) {
        list.splice(0, list.length - max);
      }
    }

    function addHistoryEntry(list, value) {
      if (!Array.isArray(list)) return false;
      const normalized = normalizeHistoryValue(value);
      if (!normalized) return false;
      const lower = normalized.toLocaleLowerCase("fr-FR");
      const existingIndex = list.findIndex(
        (entry) => entry.toLocaleLowerCase("fr-FR") === lower
      );
      if (existingIndex >= 0) {
        if (existingIndex === list.length - 1) {
          return false;
        }
        list.splice(existingIndex, 1);
        list.push(normalized);
        return true;
      }
      list.push(normalized);
      trimHistoryList(list);
      return true;
    }

    function sanitizePreset(details, client, name) {
      if (!details || typeof details !== "object") return null;
      return {
        client: normalizeHistoryValue(client ?? details.client),
        name: normalizeHistoryValue(name ?? details.name),
        qty:
          details.qty !== undefined && details.qty !== null && details.qty !== ""
            ? String(details.qty)
            : "",
        diam: typeof details.diam === "string" ? details.diam : "",
        finish: typeof details.finish === "string" ? details.finish : "",
        type: typeof details.type === "string" ? details.type : "",
        carton: typeof details.carton === "string" ? details.carton : "",
      };
    }

    function isSamePreset(a, b) {
      if (!a || !b) return false;
      return (
        normalizeHistoryValue(a.client) === normalizeHistoryValue(b.client) &&
        normalizeHistoryValue(a.name) === normalizeHistoryValue(b.name) &&
        (a.qty || "") === (b.qty || "") &&
        (a.diam || "") === (b.diam || "") &&
        (a.finish || "") === (b.finish || "") &&
        (a.type || "") === (b.type || "") &&
        (a.carton || "") === (b.carton || "")
      );
    }

    function loadFormHistory() {
      try {
        const raw = JSON.parse(localStorage.getItem(FORM_HISTORY) || "{}");
        const clients = Array.isArray(raw?.clients)
          ? raw.clients.map(normalizeHistoryValue).filter(Boolean)
          : [];
        const names = Array.isArray(raw?.names)
          ? raw.names.map(normalizeHistoryValue).filter(Boolean)
          : [];
        const combos = {};
        if (raw?.combos && typeof raw.combos === "object") {
          for (const [key, value] of Object.entries(raw.combos)) {
            const preset = sanitizePreset(value, value?.client, value?.name);
            if (key && preset) combos[key] = preset;
          }
        }
        const lastByClient = {};
        if (raw?.lastByClient && typeof raw.lastByClient === "object") {
          for (const [key, value] of Object.entries(raw.lastByClient)) {
            const preset = sanitizePreset(value, value?.client, value?.name);
            if (key && preset) lastByClient[key] = preset;
          }
        }
        const lastByName = {};
        if (raw?.lastByName && typeof raw.lastByName === "object") {
          for (const [key, value] of Object.entries(raw.lastByName)) {
            const preset = sanitizePreset(value, value?.client, value?.name);
            if (key && preset) lastByName[key] = preset;
          }
        }
        return {
          clients,
          names,
          combos,
          lastByClient,
          lastByName,
        };
      } catch (err) {
        console.warn("Impossible de lire l'historique du formulaire", err);
        return { clients: [], names: [], combos: {}, lastByClient: {}, lastByName: {} };
      }
    }

    function persistFormHistory() {
      try {
        const payload = {
          clients: Array.isArray(formHistory?.clients)
            ? formHistory.clients.slice(-HISTORY_LIMIT)
            : [],
          names: Array.isArray(formHistory?.names)
            ? formHistory.names.slice(-HISTORY_LIMIT)
            : [],
          combos: formHistory?.combos || {},
          lastByClient: formHistory?.lastByClient || {},
          lastByName: formHistory?.lastByName || {},
        };
        localStorage.setItem(FORM_HISTORY, JSON.stringify(payload));
      } catch (err) {
        console.warn("Impossible de sauvegarder l'historique du formulaire", err);
      }
    }

    function addToFormHistory(client, name, persist = true, details = null) {
      if (!formHistory) {
        formHistory = { clients: [], names: [], combos: {}, lastByClient: {}, lastByName: {} };
      }
      const normalizedClient = normalizeHistoryValue(client);
      const normalizedName = normalizeHistoryValue(name);
      let changed = false;

      if (normalizedClient) {
        changed = addHistoryEntry(formHistory.clients, normalizedClient) || changed;
      }
      if (normalizedName) {
        changed = addHistoryEntry(formHistory.names, normalizedName) || changed;
      }

      const preset = details ? sanitizePreset(details, normalizedClient, normalizedName) : null;
      if (preset) {
        formHistory.lastByClient = formHistory.lastByClient || {};
        formHistory.lastByName = formHistory.lastByName || {};
        formHistory.combos = formHistory.combos || {};
        const clientKey = historyKey(normalizedClient);
        const nameKey = historyKey(normalizedName);
        const comboKey = makeComboKey(normalizedClient, normalizedName);

        if (clientKey) {
          const prev = formHistory.lastByClient[clientKey];
          if (!prev || !isSamePreset(prev, preset)) {
            formHistory.lastByClient[clientKey] = { ...preset };
            changed = true;
          }
        }
        if (nameKey) {
          const prev = formHistory.lastByName[nameKey];
          if (!prev || !isSamePreset(prev, preset)) {
            formHistory.lastByName[nameKey] = { ...preset };
            changed = true;
          }
        }
        if (comboKey) {
          const prev = formHistory.combos[comboKey];
          if (!prev || !isSamePreset(prev, preset)) {
            formHistory.combos[comboKey] = { ...preset };
            changed = true;
          }
        }
      }

      if (persist && changed) {
        persistFormHistory();
      }
      if (persist) {
        updateHistorySuggestions();
      }

      return changed;
    }

    function findHistoryPreset(client, name) {
      if (!formHistory) return null;
      const comboKey = makeComboKey(client, name);
      if (comboKey && formHistory.combos?.[comboKey]) {
        return formHistory.combos[comboKey];
      }
      const nameKey = historyKey(name);
      if (nameKey && formHistory.lastByName?.[nameKey]) {
        return formHistory.lastByName[nameKey];
      }
      const clientKey = historyKey(client);
      if (clientKey && formHistory.lastByClient?.[clientKey]) {
        return formHistory.lastByClient[clientKey];
      }
      return null;
    }

    function applyPresetToFields(preset, fields) {
      if (!preset || !fields) return;
      if (fields.fQty && preset.qty) {
        fields.fQty.value = preset.qty;
      }
      if (fields.fDiam && hasSelectOption(fields.fDiam, preset.diam)) {
        fields.fDiam.value = preset.diam;
      }
      if (fields.fFinish && hasSelectOption(fields.fFinish, preset.finish)) {
        fields.fFinish.value = preset.finish;
      }
      if (fields.fType && hasSelectOption(fields.fType, preset.type)) {
        fields.fType.value = preset.type;
      }
      if (fields.fCarton && hasSelectOption(fields.fCarton, preset.carton)) {
        fields.fCarton.value = preset.carton;
      }
    }

    function seedFormHistoryFromItems(list) {
      if (!Array.isArray(list)) {
        updateHistorySuggestions();
        return;
      }
      const sorted = [...list].sort(
        (a, b) => (a?.startTime || 0) - (b?.startTime || 0)
      );
      let changed = false;
      for (const item of sorted) {
        if (!item) continue;
        const details = {
          qty: item.qty,
          diam: item.diam,
          finish: item.finish,
          type: item.type,
          carton: item.carton,
        };
        if (addToFormHistory(item.client, item.name, false, details)) {
          changed = true;
        }
      }
      if (changed) {
        persistFormHistory();
      }
      updateHistorySuggestions();
    }

    function uniqueSortedHistory(values) {
      const seen = new Set();
      const result = [];
      for (const value of values || []) {
        const normalized = normalizeHistoryValue(value);
        if (!normalized) continue;
        const key = normalized.toLocaleLowerCase("fr-FR");
        if (seen.has(key)) continue;
        seen.add(key);
        result.push(normalized);
      }
      return result.sort((a, b) => a.localeCompare(b, "fr", { sensitivity: "base" }));
    }

    function renderHistoryOptions(target, values) {
      if (!target) return;
      target.innerHTML = values
        .map((value) => `<option value="${escapeHtml(value)}"></option>`)
        .join("");
    }

    function updateHistorySuggestions() {
      if (!clientHistoryList && !nameHistoryList) return;
      const clientsSource = [
        ...(formHistory?.clients || []),
        ...items.map((item) => item?.client),
      ];
      const namesSource = [
        ...(formHistory?.names || []),
        ...items.map((item) => item?.name),
      ];
      renderHistoryOptions(clientHistoryList, uniqueSortedHistory(clientsSource));
      renderHistoryOptions(nameHistoryList, uniqueSortedHistory(namesSource));
    }

    function prefillFromHistoryIfAvailable() {
      if (!orderForm) return;
      const fields = orderForm.elements;
      const client = fields.fClient?.value || "";
      const name = fields.fName?.value || "";
      const preset = findHistoryPreset(client, name);
      if (preset) {
        applyPresetToFields(preset, fields);
      }
    }

    function loadStatsBaseline() {
      try {
        const raw = JSON.parse(localStorage.getItem(STATS_BASE) || "{}");
        if (raw && typeof raw === "object") {
          return {
            produced: Number(raw.produced) || 0,
            totalOrders: Number(raw.totalOrders) || 0,
          };
        }
      } catch (err) {
        console.warn("Impossible de lire le point de remise à zéro des compteurs", err);
      }
      return { produced: 0, totalOrders: 0 };
    }
    function persistStatsBaseline() {
      try {
        localStorage.setItem(STATS_BASE, JSON.stringify(statsBaseline));
      } catch (err) {
        console.warn("Impossible de sauvegarder le point de remise à zéro", err);
      }
    }
    function updateInsightsDisplay() {
      const badges = document.getElementById("insightBadges");
      const orders = document.getElementById("insightOrders");
      if (!badges || !orders) return;
      const base = statsBaseline || { produced: 0, totalOrders: 0 };
      const producedValue = Math.max(0, (lastStats.produced || 0) - (base.produced || 0));
      const totalValue = Math.max(0, (lastStats.totalOrders || 0) - (base.totalOrders || 0));
      badges.textContent = producedValue.toLocaleString("fr-FR");
      orders.textContent = totalValue.toLocaleString("fr-FR");

      const waitingEl = document.getElementById("insightWaiting");
      if (waitingEl) waitingEl.textContent = (lastStats.waiting || 0).toLocaleString("fr-FR");

      const pausedEl = document.getElementById("insightPaused");
      if (pausedEl) pausedEl.textContent = (lastStats.paused || 0).toLocaleString("fr-FR");

      const avgEl = document.getElementById("insightAvg");
      if (avgEl) avgEl.textContent = lastStats.avgDurationSec ? fmtDur(lastStats.avgDurationSec) : "—";

      const avgDetail = document.getElementById("insightAvgDetail");
      if (avgDetail) {
        const count = lastStats.doneCount || 0;
        avgDetail.textContent = count
          ? `${count.toLocaleString("fr-FR")} commande${count > 1 ? "s" : ""} terminée${count > 1 ? "s" : ""}`
          : "Aucune commande terminée";
      }

      const activeEl = document.getElementById("insightActive");
      if (activeEl) activeEl.textContent = lastStats.activeSec ? fmtDur(lastStats.activeSec) : "—";

      const doneCountEl = document.getElementById("insightDoneCount");
      if (doneCountEl) doneCountEl.textContent = (lastStats.doneCount || 0).toLocaleString("fr-FR");

      const completionLabel = document.getElementById("insightCompletionLabel");
      const completionBar = document.getElementById("insightCompletionBar");
      const completionRatio = Math.max(0, Math.min(1, lastStats.completion || 0));
      const completionPercent = Math.round(completionRatio * 100);
      if (completionLabel) completionLabel.textContent = `${completionPercent.toLocaleString("fr-FR")} %`;
      if (completionBar) completionBar.style.width = `${completionPercent}%`;
    }

    function updateMenuStats() {
      const totalEl = document.getElementById("menuCountTotal");
      if (totalEl) totalEl.textContent = (lastStats.totalOrders || 0).toLocaleString("fr-FR");
      const waitEl = document.getElementById("menuCountWait");
      if (waitEl) waitEl.textContent = (lastStats.waiting || 0).toLocaleString("fr-FR");
      const pauseEl = document.getElementById("menuCountPause");
      if (pauseEl) pauseEl.textContent = (lastStats.paused || 0).toLocaleString("fr-FR");
      const doneEl = document.getElementById("menuCountDone");
      if (doneEl) doneEl.textContent = (lastStats.doneCount || 0).toLocaleString("fr-FR");
      const producedEl = document.getElementById("menuProduced");
      if (producedEl) producedEl.textContent = (lastStats.produced || 0).toLocaleString("fr-FR");
      const summaryEl = document.getElementById("menuCompletionSummary");
      if (summaryEl) {
        const done = lastStats.doneCount || 0;
        const total = lastStats.totalOrders || 0;
        summaryEl.textContent = `${done.toLocaleString("fr-FR")} / ${total.toLocaleString("fr-FR")} commande${
          total > 1 ? "s" : ""
        }`;
      }
      const completionValue = Math.max(0, Math.min(1, lastStats.completion || 0));
      const completionPercent = Math.round(completionValue * 100);
      const menuCompletionLabel = document.getElementById("menuCompletionLabel");
      if (menuCompletionLabel)
        menuCompletionLabel.textContent = `${completionPercent.toLocaleString("fr-FR")} %`;
      const menuCompletionBar = document.getElementById("menuCompletionBar");
      if (menuCompletionBar) menuCompletionBar.style.width = `${completionPercent}%`;
    }

    async function ensureStoragePersistence() {
      if (!navigator.storage?.persist) return;
      try {
        const persisted = await navigator.storage.persisted();
        if (!persisted) {
          await navigator.storage.persist();
        }
      } catch (err) {
        console.warn("Storage persistence request failed", err);
      }
    }

    function getDb() {
      if (!("indexedDB" in window)) return Promise.resolve(null);
      if (!dbPromise) {
        dbPromise = new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, DB_VERSION);
          req.onerror = () => reject(req.error);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(DB_STORE)) {
              db.createObjectStore(DB_STORE, { keyPath: "id" });
            }
          };
          req.onsuccess = () => {
            const db = req.result;
            db.onversionchange = () => {
              db.close();
              dbPromise = null;
            };
            resolve(db);
          };
        }).catch((err) => {
          console.warn("IndexedDB unavailable", err);
          return null;
        });
      }
      return dbPromise;
    }

    async function loadFromIndexedDB() {
      const db = await getDb();
      if (!db) return null;
      return new Promise((resolve) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const store = tx.objectStore(DB_STORE);
        const req = store.get("items");
        req.onsuccess = () => {
          resolve(Array.isArray(req.result?.items) ? req.result.items : null);
        };
        req.onerror = () => resolve(null);
      });
    }

    function saveToIndexedDB(data) {
      getDb()
        .then((db) => {
          if (!db) return;
          const tx = db.transaction(DB_STORE, "readwrite");
          const store = tx.objectStore(DB_STORE);
          store.put({ id: "items", items: data, updatedAt: Date.now() });
          tx.onerror = () => console.warn("IndexedDB write failed", tx.error);
          tx.onabort = () => console.warn("IndexedDB write aborted", tx.error);
        })
        .catch((err) => console.warn("IndexedDB write failed", err));
    }

    async function initPersistentState() {
      await ensureStoragePersistence();
      const persisted = await loadFromIndexedDB();
      if (Array.isArray(persisted)) {
        items = persisted.map(enrichItemState);
        seedFormHistoryFromItems(items);
        render();
      } else {
        saveToIndexedDB(items);
      }
    }

    function vibrate(ms = 25) {
      if (!$("#optHaptic") || !$("#optHaptic").checked) return;
      if (navigator.vibrate) navigator.vibrate(ms);
    }
    function now() {
      return Date.now();
    }
    function fmtDate(ts) {
      if (!ts) return "—";
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "—";
      return (
        d.toLocaleDateString("fr-FR") +
        " " +
        d.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" })
      );
    }
    function fmtShortDate(ts) {
      if (!ts) return "—";
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "—";
      return d.toLocaleDateString("fr-FR");
    }
    function parseDeadlineValue(value) {
      if (value instanceof Date && !Number.isNaN(value.getTime())) {
        return value.getTime();
      }
      const num = Number(value);
      if (Number.isFinite(num) && num > 0) {
        return num;
      }
      if (typeof value !== "string") return null;
      const trimmed = value.trim();
      if (!trimmed) return null;
      const iso = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (iso) {
        const [, year, month, day] = iso;
        return new Date(Number(year), Number(month) - 1, Number(day)).getTime();
      }
      const full = trimmed.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
      if (full) {
        const [, day, month, year] = full;
        return new Date(Number(year), Number(month) - 1, Number(day)).getTime();
      }
      const short = trimmed.match(/^(\d{2})\/(\d{2})$/);
      if (short) {
        const [, day, month] = short;
        const currentYear = new Date().getFullYear();
        return new Date(currentYear, Number(month) - 1, Number(day)).getTime();
      }
      const parsed = Date.parse(trimmed);
      if (!Number.isNaN(parsed)) return parsed;
      return null;
    }
    function fmtDur(s) {
      if (!s || s < 1) return "—";
      const h = Math.floor(s / 3600),
        m = Math.floor((s % 3600) / 60),
        sec = s % 60;
      return (h ? `${h}h ` : "") + (m ? `${m}m ` : "") + (sec ? `${sec}s` : "");
    }
    function statusLabel(s) {
      return s === "done" ? "Terminée" : s === "pause" ? "En pause" : "En attente";
    }
    function escapeHtml(t) {
      return String(t).replace(/[&<>\"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[m]));
    }

    function ensureTimerFields(item) {
      if (!item || typeof item !== "object") return;
      const active = Number(item.activeMs);
      if (!Number.isFinite(active) || active < 0) {
        const fallback = Number(item.durationSec || 0) * 1000;
        item.activeMs = Number.isFinite(fallback) && fallback > 0 ? fallback : 0;
      } else {
        item.activeMs = active;
      }
      if (!Number.isFinite(Number(item.statusChangedAt))) {
        item.statusChangedAt = 0;
      }
      if (typeof item.durationSec !== "number" || Number.isNaN(item.durationSec) || item.durationSec < 0) {
        item.durationSec = item.status === "done" ? Math.floor(item.activeMs / 1000) : 0;
      }
      if (item.status === "wait") {
        item.lastResumeTime = item.lastResumeTime || item.startTime || now();
      } else if (item.status !== "wait") {
        item.lastResumeTime = null;
      }
    }

    function enrichItemState(item) {
      if (!item || typeof item !== "object") return item;
      if (!item.startTime) {
        item.startTime = now();
      }
      if ("deadline" in item) {
        const parsedDeadline = parseDeadlineValue(item.deadline);
        item.deadline = parsedDeadline;
      }
      ensureTimerFields(item);
      if (item.status === "done") {
        item.durationSec = Math.floor(item.activeMs / 1000);
      }
      return item;
    }

    function getActiveMs(item, ref = now()) {
      if (!item) return 0;
      ensureTimerFields(item);
      if (item.status === "wait" && item.lastResumeTime) {
        return item.activeMs + Math.max(0, ref - item.lastResumeTime);
      }
      return item.activeMs;
    }

    function getEffectiveSeconds(item, ref = now()) {
      return Math.floor(getActiveMs(item, ref) / 1000);
    }

    function transitionStatus(item, nextStatus, ts = now()) {
      if (!item) return;
      ensureTimerFields(item);
      const current = item.status;
      if (current === nextStatus) {
        if (nextStatus === "wait" && !item.lastResumeTime) {
          item.lastResumeTime = ts;
        }
        if (nextStatus === "done") {
          item.durationSec = Math.floor(item.activeMs / 1000);
        }
        return;
      }
      item.statusChangedAt = ts;
      if (nextStatus === "wait") {
        if (current === "wait") return;
        if (current === "done") {
          item.durationSec = Math.floor(item.activeMs / 1000);
        }
        item.status = "wait";
        item.endTime = null;
        item.lastResumeTime = ts;
        return;
      }
      if (nextStatus === "pause") {
        if (current === "wait" && item.lastResumeTime) {
          item.activeMs += Math.max(0, ts - item.lastResumeTime);
        }
        item.status = "pause";
        item.lastResumeTime = null;
        item.endTime = ts;
        item.durationSec = Math.floor(item.activeMs / 1000);
        return;
      }
      if (nextStatus === "done") {
        if (current === "wait" && item.lastResumeTime) {
          item.activeMs += Math.max(0, ts - item.lastResumeTime);
        }
        item.status = "done";
        item.lastResumeTime = null;
        item.endTime = ts;
        item.durationSec = Math.floor(item.activeMs / 1000);
        return;
      }
      item.status = nextStatus;
    }

    function newItem(o) {
      const createdAt = now();
      const start = o.startTime || createdAt;
      const status = o.status || "wait";
      const baseDuration = Number(o.durationSec || 0);
      const activeMs = Number(o.activeMs);
      let endTime = o.endTime || null;
      if (!endTime && (status === "pause" || status === "done")) {
        endTime = createdAt;
      }
      const item = {
        id: String(Date.now()) + Math.random().toString(16).slice(2),
        client: o.client.trim(),
        name: o.name.trim(),
        qty: Number(o.qty),
        diam: o.diam,
        finish: o.finish,
        type: o.type,
        carton: o.carton,
        deadline: parseDeadlineValue(o.deadline),
        status,
        note: (o.note || "").trim(),
        startTime: start,
        endTime,
        durationSec: baseDuration > 0 ? baseDuration : 0,
        activeMs: Number.isFinite(activeMs) && activeMs >= 0 ? activeMs : Math.max(0, baseDuration) * 1000,
        lastResumeTime: null,
        statusChangedAt: createdAt,
      };
      if (item.status === "wait") {
        item.lastResumeTime = o.lastResumeTime || start;
      }
      enrichItemState(item);
      if (item.status === "done") {
        item.durationSec = Math.floor(item.activeMs / 1000);
      }
      return item;
    }

    /* ====== Theme & Settings ====== */
    function markThemeActive(t) {
      document.querySelectorAll("#themes [data-theme]").forEach((c) =>
        c.classList.toggle("active", c.dataset.theme === t)
      );
    }

    function updateMenuThemeButtons(theme) {
      document.querySelectorAll("[data-theme-toggle]").forEach((btn) => {
        const isActive = btn.dataset.themeToggle === theme;
        btn.classList.toggle("is-active", isActive);
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }

    function applyTheme(theme) {
      const next = resolveTheme(theme);
      document.documentElement.setAttribute("data-theme", next);
      localStorage.setItem(THEME, next);
      markThemeActive(next);
      updateMenuThemeButtons(next);
    }

    (function initTheme() {
      const stored = localStorage.getItem(THEME);
      const theme = resolveTheme(stored);
      if (stored !== theme) {
        localStorage.setItem(THEME, theme);
      }
      applyTheme(theme);
    })();

    $("#themes").addEventListener("click", (e) => {
      const t = e.target?.dataset?.theme;
      if (!isValidTheme(t)) return;
      applyTheme(t);
      vibrate();
    });

    function updateDenseButtons(isDense) {
      document
        .querySelectorAll('[data-preference-toggle="dense"]')
        .forEach((btn) => {
          btn.classList.toggle("is-active", !!isDense);
          btn.setAttribute("aria-pressed", isDense ? "true" : "false");
        });
    }

    function setDenseMode(enabled, { persist = true } = {}) {
      const next = !!enabled;
      prefs.dense = next;
      if (persist) {
        localStorage.setItem(P, JSON.stringify(prefs));
      }
      document.body.classList.toggle("dense", next);
      const optDense = $("#optDense");
      if (optDense) optDense.checked = next;
      updateDenseButtons(next);
    }

    const prefs = (() => {
      try {
        return Object.assign(
          { emailWithDur: false, haptic: true, dense: false },
          JSON.parse(localStorage.getItem(P) || "{}")
        );
      } catch {
        return { emailWithDur: false, haptic: true, dense: false };
      }
    })();
    $("#optDur").checked = !!prefs.emailWithDur;
    $("#optHaptic").checked = !!prefs.haptic;
    $("#optDense").checked = !!prefs.dense;
    setDenseMode(prefs.dense, { persist: false });
    $("#optDur").onchange = () => {
      prefs.emailWithDur = $("#optDur").checked;
      localStorage.setItem(P, JSON.stringify(prefs));
    };
    $("#optHaptic").onchange = () => {
      prefs.haptic = $("#optHaptic").checked;
      localStorage.setItem(P, JSON.stringify(prefs));
    };
    $("#optDense").onchange = () => {
      setDenseMode($("#optDense").checked);
    };

    $("#settingsBtn").onclick = () => {
      $("#settings").classList.add("open");
      vibrate();
      syncHeaderOffset();
    };
    $("#closeSettings").onclick = () => {
      $("#settings").classList.remove("open");
      vibrate();
      syncHeaderOffset();
    };
    $("#clearAll").onclick = () => {
      if (confirm("Supprimer toutes les commandes ?")) {
        items = [];
        save();
        render();
      }
    };

    const menuBtn = $("#menuBtn");
    const commandMenu = $("#commandMenu");
    const menuOverlay = $("#menuOverlay");
    const closeMenuBtn = $("#closeMenu");
    let lastMenuFocus = null;

    function openMenu() {
      if (!commandMenu) return;
      lastMenuFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      commandMenu.classList.add("open");
      commandMenu.setAttribute("aria-hidden", "false");
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "true");
      if (menuOverlay) {
        menuOverlay.hidden = false;
        requestAnimationFrame(() => menuOverlay.classList.add("open"));
      }
      document.body.classList.add("menu-open");
      document.addEventListener("keydown", handleMenuKeydown);
      const focusTarget =
        commandMenu.querySelector(".command-menu__smart.is-active") ||
        commandMenu.querySelector("[data-smart]") ||
        commandMenu.querySelector("button");
      focusTarget?.focus({ preventScroll: true });
    }

    function closeMenu() {
      if (!commandMenu) return;
      commandMenu.classList.remove("open");
      commandMenu.setAttribute("aria-hidden", "true");
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "false");
      document.body.classList.remove("menu-open");
      if (menuOverlay) {
        menuOverlay.classList.remove("open");
        setTimeout(() => {
          if (!commandMenu.classList.contains("open")) {
            menuOverlay.hidden = true;
          }
        }, 220);
      }
      document.removeEventListener("keydown", handleMenuKeydown);
      if (lastMenuFocus && typeof lastMenuFocus.focus === "function") {
        lastMenuFocus.focus({ preventScroll: true });
      }
      lastMenuFocus = null;
    }

    function handleMenuKeydown(event) {
      if (event.key === "Escape") {
        closeMenu();
      }
    }

    function handleMenuAction(action) {
      if (!action) return;
      closeMenu();
      switch (action) {
        case "new":
          openSheet();
          break;
        case "open-insights":
          setInsightsOpen(true);
          break;
        case "open-settings":
          $("#settingsBtn")?.click();
          break;
        case "export-email":
          $("#exportEmail")?.click();
          break;
        default:
          break;
      }
      vibrate();
    }

    if (menuBtn && commandMenu) {
      menuBtn.addEventListener("click", () => {
        if (commandMenu.classList.contains("open")) closeMenu();
        else openMenu();
        vibrate();
      });
    }
    if (closeMenuBtn) {
      closeMenuBtn.addEventListener("click", () => {
        closeMenu();
        vibrate();
      });
    }
    if (menuOverlay) {
      menuOverlay.addEventListener("click", () => {
        closeMenu();
      });
    }

    document.querySelectorAll("[data-menu-action]").forEach((btn) => {
      btn.addEventListener("click", () => handleMenuAction(btn.dataset.menuAction));
    });
    document.querySelectorAll("[data-smart]").forEach((btn) => {
      btn.addEventListener("click", () => {
        setSmartFilter(btn.dataset.smart);
        vibrate();
      });
    });
    document.querySelectorAll("[data-smart-reset]").forEach((btn) => {
      btn.addEventListener("click", () => {
        setSmartFilter("default");
        vibrate();
        if (commandMenu?.classList.contains("open")) closeMenu();
      });
    });
    document.querySelectorAll("[data-sort]").forEach((btn) => {
      btn.addEventListener("click", () => {
        setSort(btn.dataset.sort);
        vibrate();
      });
    });
    document.querySelectorAll("[data-theme-toggle]").forEach((btn) => {
      btn.addEventListener("click", () => {
        applyTheme(btn.dataset.themeToggle);
        vibrate();
      });
    });
    document
      .querySelectorAll('[data-preference-toggle="dense"]')
      .forEach((btn) => {
        btn.addEventListener("click", () => {
          setDenseMode(!prefs.dense);
          vibrate();
        });
      });

    /* ====== Header offset ====== */
    function syncHeaderOffset() {
      const h = document.querySelector("header")?.offsetHeight || 180;
      document.documentElement.style.setProperty("--header-h", h + "px");
    }
    window.addEventListener("resize", syncHeaderOffset);
    window.addEventListener("orientationchange", syncHeaderOffset);
    document.addEventListener("DOMContentLoaded", syncHeaderOffset);
    setTimeout(syncHeaderOffset, 80);

    const insightPanel = $("#insights");
    const insightToggleBtn = $("#insightToggle");
    const closeInsightsBtn = $("#closeInsights");
    const resetInsightsBtn = $("#resetInsights");
    const insightsAutoOpenMq =
      typeof window.matchMedia === "function" ? window.matchMedia("(min-width: 768px)") : null;

    function setInsightsOpen(open) {
      if (!insightPanel) return;
      const forceOpen = insightsAutoOpenMq?.matches ?? false;
      const nextOpen = forceOpen || !!open;
      insightPanel.classList.toggle("open", nextOpen);
      insightPanel.setAttribute("aria-hidden", String(!nextOpen));
      if (insightToggleBtn) {
        insightToggleBtn.setAttribute("aria-expanded", String(nextOpen));
      }
    }

    if (insightToggleBtn && insightPanel) {
      insightToggleBtn.addEventListener("click", () => {
        if (insightsAutoOpenMq?.matches) return;
        const isOpen = insightPanel.classList.contains("open");
        setInsightsOpen(!isOpen);
        vibrate();
      });
    }
    if (closeInsightsBtn) {
      closeInsightsBtn.addEventListener("click", () => {
        if (insightsAutoOpenMq?.matches) return;
        setInsightsOpen(false);
        vibrate();
      });
    }
    if (resetInsightsBtn) {
      resetInsightsBtn.addEventListener("click", () => {
        statsBaseline = { produced: lastStats.produced, totalOrders: lastStats.totalOrders };
        persistStatsBaseline();
        updateInsightsDisplay();
        vibrate();
      });
    }
    document.addEventListener("keydown", (e) => {
      if (insightsAutoOpenMq?.matches) return;
      if (e.key === "Escape") setInsightsOpen(false);
    });
    document.addEventListener("click", (e) => {
      if (insightsAutoOpenMq?.matches) return;
      if (!insightPanel?.classList.contains("open")) return;
      if (insightPanel.contains(e.target)) return;
      if (insightToggleBtn?.contains(e.target)) return;
      setInsightsOpen(false);
    });

    if (insightsAutoOpenMq) {
      const handleMqChange = (event) => {
        setInsightsOpen(event.matches);
      };
      if (typeof insightsAutoOpenMq.addEventListener === "function") {
        insightsAutoOpenMq.addEventListener("change", handleMqChange);
      } else if (typeof insightsAutoOpenMq.addListener === "function") {
        insightsAutoOpenMq.addListener(handleMqChange);
      }
    }

    setInsightsOpen(insightsAutoOpenMq?.matches ?? false);
    updateInsightsDisplay();

    /* ====== Filters, search, sort ====== */
    function syncFilterChips() {
      document.querySelectorAll("#filters .chip").forEach((chip) => {
        chip.classList.toggle("active", chip.dataset.f === filter);
      });
    }

    function setStatusFilter(value, { fromUser = false, skipRender = false } = {}) {
      const next = value || "all";
      const changed = filter !== next;
      filter = next;
      if (fromUser) {
        filterBeforeSmart = next;
      } else if (smartFilter === "default") {
        filterBeforeSmart = next;
      }
      if (skipRender) {
        syncFilterChips();
        return;
      }
      if (changed) {
        render();
      } else {
        syncFilterChips();
        updateSmartFilterUI();
        updateSmartFilterBadge();
      }
    }

    function setSort(value, { skipRender = false } = {}) {
      const next = value || "recent";
      if (sortBy === next) {
        updateSortMenuUI();
        if (!skipRender) render();
        return;
      }
      sortBy = next;
      localStorage.setItem("vmach_sort", sortBy);
      updateSortMenuUI();
      if (!skipRender) render();
    }

    function setSmartFilter(next) {
      const resolved = resolveSmartFilter(next);
      if (resolved === smartFilter) {
        updateSmartFilterUI();
        updateSmartFilterBadge();
        return;
      }
      const previousSmart = smartFilter;
      smartFilter = resolved;
      localStorage.setItem(SMART_FILTER_KEY, smartFilter);
      if (previousSmart === "default" && smartFilter !== "default") {
        filterBeforeSmart = filter;
      }
      if (smartFilter === "default") {
        setStatusFilter(filterBeforeSmart, { skipRender: true });
      } else if (smartFilter === "recentDone") {
        setStatusFilter("done", { skipRender: true });
      } else if (smartFilter === "urgent" || smartFilter === "highVolume") {
        if (filter === "done") {
          setStatusFilter("all", { skipRender: true });
        }
      }
      render();
    }

    [...document.querySelectorAll("#filters button")].forEach((b) => {
      b.addEventListener("click", () => {
        setStatusFilter(b.dataset.f, { fromUser: true });
        vibrate();
      });
    });
    $("#q").oninput = (e) => {
      search = e.target.value.trim().toLowerCase();
      render();
    };
    /* ====== Add/Edit Sheet ====== */
    const sheet = $("#sheet");
    const orderForm = $("#orderForm");
    function openSheet(edit = null) {
      editId = edit ? edit.id : null;
      $("#sheetTitle").textContent = edit ? "Modifier la commande" : "Nouvelle commande";
      if (orderForm) {
        orderForm.reset();
        const fields = orderForm.elements;
        if (fields.fStatus) fields.fStatus.value = "wait";
        if (edit) {
          fields.fClient.value = edit.client || "";
          fields.fName.value = edit.name || "";
          fields.fQty.value = edit.qty || "";
          fields.fDiam.value = edit.diam || "";
          fields.fFinish.value = edit.finish || "";
          fields.fType.value = edit.type || "";
          fields.fCarton.value = edit.carton || "";
          fields.fStatus.value = edit.status || "wait";
          fields.fNote.value = edit.note || "";
        } else {
          applyLastFormValues(fields);
        }
        setTimeout(() => fields.fClient?.focus(), 100);
      }
      sheet.classList.add("open");
      sheet.setAttribute("aria-hidden", "false");
      syncHeaderOffset();
    }
    function closeSheet() {
      sheet.classList.remove("open");
      sheet.setAttribute("aria-hidden", "true");
      editId = null;
      syncHeaderOffset();
    }

    $("#fab").onclick = () => {
      openSheet();
      vibrate();
    };
    $("#cancelBtn").onclick = () => {
      closeSheet();
      vibrate();
    };

    if (orderForm) {
      const attachHistoryPrefill = (el) => {
        if (!el) return;
        el.addEventListener("change", prefillFromHistoryIfAvailable);
        el.addEventListener("blur", prefillFromHistoryIfAvailable);
        el.addEventListener("input", prefillFromHistoryIfAvailable);
      };
      attachHistoryPrefill(orderForm.elements.fClient);
      attachHistoryPrefill(orderForm.elements.fName);

      orderForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const fields = orderForm.elements;
        const clientValue = fields.fClient.value.trim();
        const nameValue = fields.fName.value.trim();
        const o = {
          client: clientValue,
          name: nameValue,
          qty: fields.fQty.value,
          diam: fields.fDiam.value,
          finish: fields.fFinish.value,
          type: fields.fType.value,
          carton: fields.fCarton.value,
          status: fields.fStatus.value,
          note: fields.fNote.value,
        };
        if (!o.client || !o.name || !o.qty || !o.diam || !o.finish || !o.type || !o.carton) {
          alert("Merci de remplir tous les champs obligatoires.");
          return;
        }

        rememberLastFormValues(fields);
        addToFormHistory(clientValue, nameValue, true, {
          qty: o.qty,
          diam: o.diam,
          finish: o.finish,
          type: o.type,
          carton: o.carton,
        });

        if (editId) {
          const ix = items.findIndex((x) => x.id === editId);
          if (ix >= 0) {
            const item = items[ix];
            const prevStatus = item.status;
            const nextStatus = o.status || "wait";
            Object.assign(item, o);
            enrichItemState(item);
            item.status = prevStatus;
            transitionStatus(item, nextStatus, now());
            if (nextStatus === "done" && prevStatus !== "done") {
              confettiBurst();
            }
          }
        } else {
          const created = newItem(o);
          items.unshift(created);
          cardInAnimationNextRender = true;
          transitionStatus(created, created.status, now());
          if (created.status === "done") {
            confettiBurst();
          }
        }
        save();
        render();
        closeSheet();
        vibrate();
      });
    }

    /* ====== Render ====== */
    let cardInAnimationNextRender = false;

    function computeStats() {
      const nowTs = now();
      const doneItems = items.filter((i) => i.status === "done");
      const produced = doneItems.reduce((total, item) => total + (Number(item.qty) || 0), 0);
      const totalOrders = items.length;
      const waiting = items.filter((i) => i.status === "wait").length;
      const paused = items.filter((i) => i.status === "pause").length;
      const doneActiveMs = doneItems.reduce((sum, item) => sum + getActiveMs(item, nowTs), 0);
      const avgDurationSec = doneItems.length ? Math.round(doneActiveMs / doneItems.length / 1000) : 0;
      const activeSec = Math.floor(
        items.reduce((sum, item) => sum + getActiveMs(item, nowTs), 0) / 1000
      );
      const completion = totalOrders ? doneItems.length / totalOrders : 0;
      lastStats = {
        produced,
        totalOrders,
        waiting,
        paused,
        avgDurationSec,
        activeSec,
        completion,
        doneCount: doneItems.length,
      };
      updateInsightsDisplay();
      updateMenuStats();
    }

    function sortItems(list) {
      const copy = [...list];
      if (sortBy === "recent") copy.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
      else if (sortBy === "oldest") copy.sort((a, b) => (a.startTime || 0) - (b.startTime || 0));
      else if (sortBy === "qty") copy.sort((a, b) => (b.qty || 0) - (a.qty || 0));
      else if (sortBy === "client")
        copy.sort((a, b) => a.client.localeCompare(b.client, "fr", { sensitivity: "base" }));
      else if (sortBy === "status") {
        const order = { wait: 0, pause: 1, done: 2 };
        copy.sort((a, b) => order[a.status] - order[b.status]);
      }
      return copy;
    }

    function applySmartFilter(list, ts) {
      if (!Array.isArray(list)) return [];
      if (smartFilter === "urgent") {
        return list.filter((item) => {
          if (!item || item.status === "done") return false;
          const startRef = item.lastResumeTime || item.startTime || 0;
          if (!startRef) return false;
          return ts - startRef >= URGENT_DELAY_MS;
        });
      }
      if (smartFilter === "highVolume") {
        return list.filter((item) => Number(item?.qty) >= HIGH_VOLUME_QTY);
      }
      if (smartFilter === "recentDone") {
        return list.filter((item) => {
          if (!item || item.status !== "done") return false;
          const end = item.endTime || item.startTime || 0;
          if (!end) return false;
          return ts - end <= RECENT_DONE_MS;
        });
      }
      return list;
    }

    function updateSmartFilterUI(visibleCount = 0) {
      document.querySelectorAll("[data-smart]").forEach((btn) => {
        const isActive = btn.dataset.smart === smartFilter;
        btn.classList.toggle("is-active", isActive);
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
      const summary = document.getElementById("smartFilterSummary");
      if (summary) summary.textContent = getSmartFilterConfig(smartFilter).description;
      const countEl = document.getElementById("smartFilterCount");
      if (countEl) countEl.textContent = Number(visibleCount).toLocaleString("fr-FR");
    }

    function updateSmartFilterBadge() {
      const badge = document.getElementById("smartFilterBadge");
      if (!badge) return;
      const labelEl = document.getElementById("smartFilterBadgeLabel");
      if (smartFilter === "default") {
        badge.hidden = true;
        badge.setAttribute("aria-hidden", "true");
        return;
      }
      badge.hidden = false;
      badge.setAttribute("aria-hidden", "false");
      if (labelEl) labelEl.textContent = getSmartFilterConfig(smartFilter).label;
    }

    function updateSortMenuUI() {
      document.querySelectorAll("[data-sort]").forEach((btn) => {
        const isActive = btn.dataset.sort === sortBy;
        btn.classList.toggle("is-active", isActive);
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }

    function render() {
      items.forEach(enrichItemState);
      computeStats();
      updateHistorySuggestions();
      const list = listEl;

      syncFilterChips();

      // stop previous live timer (global unique)
      if (liveTimer) {
        clearInterval(liveTimer);
        liveTimer = null;
      }

      const nowTs = now();

      // filter + search
      const filtered = items.filter((i) => {
        if (filter !== "all" && i.status !== filter) return false;
        if (!search) return true;
        const s = (
          i.client +
          " " +
          i.name +
          " " +
          i.diam +
          " " +
          i.finish +
          " " +
          i.type +
          " " +
          (i.carton || "") +
          " " +
          (i.note || "") +
          " " +
          (i.deadline ? fmtShortDate(i.deadline) : "")
        ).toLowerCase();
        return s.includes(search);
      });

      const smartFiltered = applySmartFilter(filtered, nowTs);
      const show = sortItems(smartFiltered);

      list.innerHTML = show
        .map((i) => {
          const isWait = i.status === "wait";
          const liveSec = getEffectiveSeconds(i, nowTs);
          const longAwait = isWait && nowTs - (i.startTime || nowTs) > 3600 * 1000;
          const justChanged =
            Number.isFinite(i.statusChangedAt) && i.statusChangedAt > 0 && nowTs - i.statusChangedAt < 1400;
          const classes = ["card"];
          if (longAwait) classes.push("awaiting-long");
          if (justChanged) classes.push("card--status-flash");
          const cardClassName = classes.join(" ");
          const badgeClasses = justChanged ? "badge badge--pulse" : "badge";
          const pauseLabel = i.status === "pause" ? "Reprendre" : "Pause";
          const pauseIcon = i.status === "pause" ? ICONS.play : ICONS.pause;
          const doneLabel = i.status === "done" ? "Reprendre" : "Terminer";
          const doneIcon = i.status === "done" ? ICONS.refresh : ICONS.check;
          return `
          <div class="${cardClassName}" data-id="${i.id}" data-status="${i.status}">
            <div class="row">
              <div class="handle" title="Déplacer">≡</div>
              <div class="title"><span>${escapeHtml(i.name)}</span></div>
              <span class="${badgeClasses}" data-s="${i.status}">${statusLabel(i.status)}</span>
            </div>
            <div class="meta">
              <span>Client : <b>${escapeHtml(i.client)}</b></span>
              <span>Qté : <b>${i.qty}</b></span>
              <span>${i.diam}</span><span>${i.finish}</span><span>${i.type}</span><span>${i.carton}</span>
            </div>
            ${
              i.deadline
                ? `<div class="meta"><span>Échéance : <b>${fmtShortDate(i.deadline)}</b></span></div>`
                : ""
            }
            <div class="meta">
              <span>Créé : ${fmtDate(i.startTime)}</span>
              ${
                i.status === "done"
                  ? `<span>Durée effective : <b>${fmtDur(i.durationSec || liveSec)}</b></span><span>Terminé : ${fmtDate(
                      i.endTime
                    )}</span>`
                  : i.status === "pause"
                  ? `<span>En pause : <b>${fmtDur(liveSec)}</b></span><span>Dernier arrêt : ${fmtDate(
                      i.endTime
                    )}</span>`
                  : `<span>En cours : <b data-role="timer">${fmtDur(liveSec)}</b></span>`
              }
            </div>
            ${i.note ? `<div class="note">📝 ${escapeHtml(i.note)}</div>` : ""}
            <div class="actions">
              <button class="btn" type="button" data-a="edit" title="Éditer" aria-label="Éditer">${ICONS.edit}<span class="sr-only">Éditer</span></button>
              <button class="btn" type="button" data-a="pause" title="${pauseLabel}" aria-label="${pauseLabel}">${pauseIcon}<span class="sr-only">${pauseLabel}</span></button>
              <button class="btn" type="button" data-a="done" title="${doneLabel}" aria-label="${doneLabel}">${doneIcon}<span class="sr-only">${doneLabel}</span></button>
              <button class="btn" type="button" data-a="del" title="Supprimer" aria-label="Supprimer">${ICONS.trash}<span class="sr-only">Supprimer</span></button>
            </div>
          </div>
        `;
        })
        .join("");

      updateSmartFilterUI(show.length);
      updateSmartFilterBadge();
      updateSortMenuUI();

      const hasItems = show.length > 0;
      if (emptyStateEl) emptyStateEl.hidden = hasItems;
      if (list) list.hidden = !hasItems;

      // anim carte à l'ajout
      if (cardInAnimationNextRender && list.firstElementChild) {
        const firstCard = list.firstElementChild;
        firstCard.classList.add("card--enter");
        cardInAnimationNextRender = false;
      }

      const waitItemsMap = new Map(
        show.filter((item) => item.status === "wait").map((item) => [item.id, item])
      );

      if (list && list.children.length && waitItemsMap.size) {
        // live timer uniquement pour "wait"
        liveTimer = setInterval(() => {
          const tick = now();
          for (let i = 0; i < list.children.length; i++) {
            const card = list.children[i];
            const id = card.getAttribute("data-id");
            if (!id) continue;
            const it = waitItemsMap.get(id);
            if (!it) continue;
            const timerEl = card.querySelector("[data-role='timer']");
            if (!timerEl) continue;
            const d = getEffectiveSeconds(it, tick);
            timerEl.textContent = fmtDur(d);
          }
        }, 1000);
      }

      ensureSortable();
    }


    function handleListClick(e) {
      const card = e.target.closest(".card");
      if (!card) return;
      const id = card.dataset.id;
      const ix = items.findIndex((x) => x.id === id);
      if (ix < 0) return;
      const act = e.target.closest("[data-a]")?.dataset.a;
      if (!act) return;

      if (act === "edit") {
        openSheet(items[ix]);
        vibrate();
        return;
      }

      if (act === "pause") {
        const ts = now();
        if (items[ix].status === "pause") {
          transitionStatus(items[ix], "wait", ts);
        } else {
          transitionStatus(items[ix], "pause", ts);
        }
        save();
        render();
        vibrate();
        return;
      }

      if (act === "done") {
        const ts = now();
        if (items[ix].status !== "done") {
          transitionStatus(items[ix], "done", ts);
          confettiBurst();
        } else {
          transitionStatus(items[ix], "wait", ts);
        }
        save();
        render();
        vibrate();
        return;
      }

      if (act === "del") {
        const item = items[ix];
        requestDeletion(
          item,
          () => {
            card.style.transform = "translateX(-110%)";
            card.style.opacity = ".0";
            setTimeout(() => {
              items.splice(ix, 1);
              save();
              render();
            }, 200);
            vibrate(35);
          },
          () => resetSwipeStyles(card)
        );
        return;
      }
    }

    function ensureSortable() {
      if (sortableInstance || !listEl || typeof Sortable === "undefined") return;
      sortableInstance = new Sortable(listEl, {
        handle: ".handle",
        animation: 160,
        onEnd: handleSortEnd,
      });

    }

    function handleSortEnd() {
      const cards = Array.from(listEl.querySelectorAll(".card"));
      const visibleIds = cards.map((c) => c.dataset.id);
      const map = new Map(visibleIds.map((id, i) => [id, i]));
      items = items
        .slice()
        .sort((a, b) => {
          const ia = map.has(a.id) ? map.get(a.id) + 0.1 : 9999 + items.indexOf(a);
          const ib = map.has(b.id) ? map.get(b.id) + 0.1 : 9999 + items.indexOf(b);
          return ia - ib;
        });
      save();
      render();
      vibrate();
    }

    function resetSwipeStyles(card) {
      if (!card) return;
      card.style.transform = "";
      card.style.opacity = "";
    }

    function requestDeletion(item, onConfirm, onCancel) {
      const label = item?.name ? `« ${item.name} »` : "cette commande";
      const confirmed = confirm(`Supprimer ${label} ?`);
      if (confirmed) {
        onConfirm?.();
      } else {
        onCancel?.();
      }
      return confirmed;
    }

    function onTouchStart(e) {
      const card = e.target.closest(".card");
      if (!card) return;
      swipeCard = card;
      swipeStartX = e.touches[0]?.clientX || 0;
      swipeStartY = e.touches[0]?.clientY || 0;
      swipeIsHorizontal = false;
      swipeMoving = true;
      card.style.transition = "";
    }

    function onTouchMove(e) {
      if (!swipeMoving || !swipeCard) return;
      const touch = e.touches[0];
      const touchX = touch?.clientX;
      const touchY = touch?.clientY;
      if (typeof touchX !== "number" || typeof touchY !== "number") return;
      const dx = touchX - swipeStartX;
      const dy = touchY - swipeStartY;
      if (Math.abs(dx) > 6) onPressEnd();

      const verticalDominant = Math.abs(dy) > 10 && Math.abs(dy) >= Math.abs(dx);
      if (verticalDominant) {
        swipeIsHorizontal = false;
        resetSwipeStyles(swipeCard);
        return;
      }

      if (!swipeIsHorizontal) {
        if (Math.abs(dx) > 10 && Math.abs(dx) >= Math.abs(dy)) {
          swipeIsHorizontal = true;
        } else {
          return;
        }
      }

      if (dx > -10) return;
      swipeCard.style.transform = `translateX(${dx}px)`;
      swipeCard.style.opacity = String(1 - Math.min(1, Math.abs(dx) / 180));
    }

    function onTouchEnd(e) {
      if (!swipeCard) return;
      const card = swipeCard;
      const touchX = e.changedTouches[0]?.clientX;
      const dx = (touchX ?? swipeStartX) - swipeStartX;
      swipeMoving = false;
      const wasHorizontal = swipeIsHorizontal;
      swipeIsHorizontal = false;
      swipeCard = null;
      card.style.transition = ".18s";
      if (wasHorizontal && dx < -90) {
        const id = card.dataset.id;
        const item = items.find((it) => it.id === id);
        const confirmed =
          item &&
          requestDeletion(
            item,
            () => {
              items = items.filter((it) => it.id !== id);
              save();
              render();
              vibrate(35);
            },
            () => resetSwipeStyles(card)
          );
        if (confirmed) {
          onPressEnd();
          return;
        }
      }
      resetSwipeStyles(card);
      onPressEnd();
    }

    function onTouchCancel() {
      if (!swipeCard) return;
      swipeCard.style.transition = ".18s";
      resetSwipeStyles(swipeCard);
      swipeMoving = false;
      swipeIsHorizontal = false;
      swipeCard = null;
      onPressEnd();
    }

    // long-press logic
    let pressTimer = null;
    function onPressStart(e) {
      const card = e.target.closest(".card");
      if (!card) return;
      const id = card.dataset.id;
      const item = items.find((x) => x.id === id);
      if (!item) return;
      pressTimer = setTimeout(() => {
        openSheet(item);
        vibrate();
      }, 600);
    }
    function onPressEnd() {
      clearTimeout(pressTimer);
      pressTimer = null;
    }

    if (listEl) {
      listEl.addEventListener("click", handleListClick);
      listEl.addEventListener("pointerdown", onPressStart);
      listEl.addEventListener("pointerup", onPressEnd);
      listEl.addEventListener("pointercancel", onPressEnd);
      listEl.addEventListener("touchstart", onTouchStart, { passive: true });
      listEl.addEventListener("touchmove", onTouchMove, { passive: true });
      listEl.addEventListener("touchend", onTouchEnd);
      listEl.addEventListener("touchcancel", onTouchCancel);
    }

    const CSV_REQUIRED_FIELDS = [
      "client",
      "name",
      "qty",
      "diam",
      "finish",
      "type",
      "carton",
    ];
    const CSV_HEADER_ALIASES = {
      client: "client",
      name: "name",
      nom: "name",
      badge: "name",
      designation: "name",
      qty: "qty",
      quantity: "qty",
      quantite: "qty",
      quantité: "qty",
      qte: "qty",
      qt: "qty",
      diam: "diam",
      diametre: "diam",
      diamètre: "diam",
      format: "diam",
      finish: "finish",
      finition: "finish",
      type: "type",
      attache: "type",
      attach: "type",
      attachment: "type",
      carton: "carton",
      colis: "carton",
      boite: "carton",
      boîte: "carton",
      box: "carton",
      deadline: "deadline",
      echeance: "deadline",
      due: "deadline",
      status: "status",
      statut: "status",
      starttime: "startTime",
      start: "startTime",
      debut: "startTime",
      début: "startTime",
      endtime: "endTime",
      end: "endTime",
      fin: "endTime",
      completion: "endTime",
      durationsec: "durationSec",
      duration: "durationSec",
      duree: "durationSec",
      durée: "durationSec",
      note: "note",
      commentaires: "note",
      comment: "note",
      activems: "activeMs",
      activeseconds: "activeSec",
      activetime: "activeMs",
      tempsactif: "activeMs",
      lastresumetime: "lastResumeTime",
      reprise: "lastResumeTime",
    };

    function normalizeCsvHeaderKey(key) {
      if (!key) return null;
      const trimmed = String(key).trim();
      if (!trimmed) return null;
      let normalized = trimmed;
      if (typeof normalized.normalize === "function") {
        normalized = normalized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }
      const lookup = normalized.toLowerCase().replace(/[^a-z0-9]/g, "");
      return CSV_HEADER_ALIASES[lookup] || trimmed;
    }

    function parseCsvLine(line) {
      const cells = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (i === 0 && char === "\ufeff") continue; // strip BOM
        if (inQuotes) {
          if (char === "\"") {
            if (line[i + 1] === "\"") {
              current += "\"";
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else {
          if (char === "\"") {
            inQuotes = true;
          } else if (char === ";") {
            cells.push(current);
            current = "";
          } else if (char === "\r") {
            continue;
          } else {
            current += char;
          }
        }
      }
      cells.push(current);
      return cells;
    }

    function parseCsvContent(text) {
      if (typeof text !== "string" || !text.trim()) {
        throw new Error("Fichier CSV vide.");
      }
      const rawLines = text.split(/\r?\n/);
      while (rawLines.length && !rawLines[0].trim()) {
        rawLines.shift();
      }
      if (!rawLines.length) {
        throw new Error("Fichier CSV vide.");
      }
      let headerLine = rawLines.shift();
      if (!headerLine || !headerLine.trim()) {
        throw new Error("Ligne d'en-tête manquante.");
      }
      const headerCells = parseCsvLine(headerLine);
      if (!headerCells.length) {
        throw new Error("Ligne d'en-tête invalide.");
      }
      const headerInfo = headerCells.map((cell) => {
        const canonical = normalizeCsvHeaderKey(cell);
        return { original: cell, canonical };
      });
      const canonicalHeader = headerInfo
        .map((info) => info.canonical)
        .filter((key) => !!key);
      const missing = CSV_REQUIRED_FIELDS.filter((field) => !canonicalHeader.includes(field));
      if (missing.length) {
        throw new Error(
          `Colonnes manquantes : ${missing.join(", ")}`
        );
      }
      const entries = [];
      rawLines.forEach((line, idx) => {
        if (!line || !line.trim()) return;
        const values = parseCsvLine(line);
        if (values.length === 1 && !values[0].trim()) return;
        if (values.length !== headerCells.length) {
          throw new Error(
            `Ligne ${idx + 2} : nombre de colonnes inattendu (${values.length} au lieu de ${headerCells.length}).`
          );
        }
        const record = {};
        headerInfo.forEach((info, col) => {
          if (!info.canonical) return;
          record[info.canonical] = (values[col] ?? "").trim();
        });
        entries.push({ data: record, lineNumber: idx + 2 });
      });
      return entries;
    }

    function normalizeStatusValue(raw) {
      if (!raw && raw !== 0) return "wait";
      const txt = String(raw)
        .trim()
        .toLowerCase();
      if (["done", "terminee", "terminée", "complete", "completed"].includes(txt)) return "done";
      if (["pause", "paused", "en pause"].includes(txt)) return "pause";
      if (["wait", "waiting", "attente", "en attente"].includes(txt)) return "wait";
      return "wait";
    }

    function parsePositiveInteger(value, lineNumber, fieldLabel) {
      const normalized = String(value ?? "")
        .trim()
        .replace(/\s+/g, "")
        .replace(/,/g, ".");
      const num = Number(normalized);
      if (!Number.isFinite(num) || num <= 0) {
        throw new Error(`Ligne ${lineNumber} : ${fieldLabel} invalide.`);
      }
      return Math.max(1, Math.round(num));
    }

    function parseOptionalNumber(value, lineNumber, fieldLabel) {
      if (value === undefined || value === null) return null;
      const str = String(value).trim();
      if (!str) return null;
      const normalized = str.replace(/\s+/g, "").replace(/,/g, ".");
      const num = Number(normalized);
      if (!Number.isFinite(num)) {
        throw new Error(`Ligne ${lineNumber} : ${fieldLabel} invalide.`);
      }
      return num;
    }

    function parseOptionalTimestamp(value, lineNumber, fieldLabel) {
      if (value === undefined || value === null) return null;
      const str = String(value).trim();
      if (!str) return null;
      const asNumber = Number(str);
      if (Number.isFinite(asNumber)) return asNumber;
      const parsed = Date.parse(str);
      if (!Number.isNaN(parsed)) return parsed;
      throw new Error(`Ligne ${lineNumber} : ${fieldLabel} invalide.`);
    }

    function generateItemId() {
      return String(Date.now()) + Math.random().toString(16).slice(2);
    }

    function recordToItem(record, lineNumber) {
      const client = (record.client || "").trim();
      const name = (record.name || "").trim();
      const diam = (record.diam || "").trim();
      const finish = (record.finish || "").trim();
      const type = (record.type || "").trim();
      const carton = (record.carton || "").trim();
      if (!client || !name || !diam || !finish || !type || !carton) {
        throw new Error(`Ligne ${lineNumber} : valeurs obligatoires manquantes.`);
      }
      const qty = parsePositiveInteger(record.qty, lineNumber, "quantité");
      const targetStatus = normalizeStatusValue(record.status);
      const durationSecRaw = parseOptionalNumber(record.durationSec, lineNumber, "durée (secondes)");
      const durationSec = Number.isFinite(durationSecRaw) ? Math.max(0, Math.round(durationSecRaw)) : 0;
      const activeMsRaw = parseOptionalNumber(record.activeMs, lineNumber, "temps actif (ms)");
      const activeSecRaw = parseOptionalNumber(record.activeSec, lineNumber, "temps actif (s)");
      const activeMs = Number.isFinite(activeMsRaw)
        ? Math.max(0, Math.round(activeMsRaw))
        : Number.isFinite(activeSecRaw)
        ? Math.max(0, Math.round(activeSecRaw * 1000))
        : null;
      const startTime = parseOptionalTimestamp(record.startTime, lineNumber, "début");
      const endTime = parseOptionalTimestamp(record.endTime, lineNumber, "fin");
      const lastResumeTime = parseOptionalTimestamp(record.lastResumeTime, lineNumber, "reprise");
      const deadline = parseDeadlineValue(record.deadline);
      const item = {
        id: generateItemId(),
        client,
        name,
        qty,
        diam,
        finish,
        type,
        carton,
        deadline,
        status: "wait",
        note: (record.note || "").trim(),
        startTime: startTime ?? now(),
        endTime: endTime ?? null,
        durationSec,
        activeMs:
          Number.isFinite(activeMs) && activeMs >= 0
            ? activeMs
            : durationSec > 0
            ? durationSec * 1000
            : 0,
        lastResumeTime: Number.isFinite(lastResumeTime) ? lastResumeTime : null,
      };
      enrichItemState(item);
      const transitionTs = Number.isFinite(endTime)
        ? endTime
        : targetStatus === "wait"
        ? item.lastResumeTime || item.startTime
        : item.startTime;
      transitionStatus(item, targetStatus, Number.isFinite(transitionTs) ? transitionTs : now());
      return item;
    }

    function importedItemKey(item) {
      return [item.client, item.name, item.diam, item.finish, item.type, item.carton]
        .map((val) => String(val || "").trim().toLowerCase())
        .join("‖");
    }

    function mergeImportedItems(existing, imported) {
      if (!Array.isArray(existing) || !existing.length) {
        return imported.slice();
      }
      const result = existing.slice();
      const indexByKey = new Map();
      result.forEach((item, idx) => {
        indexByKey.set(importedItemKey(item), idx);
      });
      imported.forEach((item) => {
        const key = importedItemKey(item);
        if (indexByKey.has(key)) {
          const idx = indexByKey.get(key);
          const preservedId = result[idx] ? result[idx].id : item.id;
          result[idx] = Object.assign({}, item, { id: preservedId || item.id });
        } else {
          result.push(item);
        }
      });
      return result;
    }

    function getBatchImportDefaults() {
      return {
        client: "",
        name: "",
        qty: 1,
        diam: lastFormValues?.diam || "58 mm",
        finish: lastFormValues?.finish || "Mat",
        type: lastFormValues?.type || "Aimant décoratif",
        carton: lastFormValues?.carton || "Boîte A11",
        deadline: null,
        note: "",
      };
    }

    async function handleCsvImportChange(event) {
      const input = event.target;
      const file = input?.files?.[0];
      if (!file) return;
      try {
        const content = await file.text();
        let importedItems = null;
        let lastError = null;
        try {
          const records = parseCsvContent(content);
          if (!records.length) {
            throw new Error("Aucune donnée trouvée dans le fichier.");
          }
          importedItems = records.map((entry) => recordToItem(entry.data, entry.lineNumber));
        } catch (err) {
          lastError = err;
          importedItems = null;
        }
        if ((!importedItems || !importedItems.length) && typeof window !== "undefined") {
          const batchParser = window.parseBatchCsv;
          if (typeof batchParser === "function") {
            try {
              const batchRecords = batchParser(content, getBatchImportDefaults()) || [];
              if (batchRecords.length) {
                importedItems = batchRecords.map((entry) => {
                  const created = newItem(entry);
                  transitionStatus(created, created.status, created.startTime || now());
                  return created;
                });
                lastError = null;
                console.info(
                  `Import CSV batch interprété (${importedItems.length} commande${
                    importedItems.length > 1 ? "s" : ""
                  }).`
                );
              }
            } catch (batchErr) {
              lastError = batchErr;
            }
          }
        }
        if (!importedItems || !importedItems.length) {
          throw lastError || new Error("Aucune donnée trouvée dans le fichier.");
        }
        const replaceAll =
          !items.length ||
          confirm(
            "Remplacer les commandes existantes par celles du fichier importé ?\nOK = remplacer complètement, Annuler = fusionner avec les commandes existantes."
          );
        const nextItems = replaceAll ? importedItems : mergeImportedItems(items, importedItems);
        items = nextItems;
        seedFormHistoryFromItems(items);
        save();
        render();
        vibrate();
        alert(
          `Import terminé : ${importedItems.length} commande${importedItems.length > 1 ? "s" : ""}.`
        );
      } catch (err) {
        console.error("Import CSV invalide", err);
        const message = err && err.message ? err.message : "Impossible de traiter le fichier.";
        alert(`Import CSV impossible : ${message}`);
      } finally {
        if (input) input.value = "";
      }
    }

    /* ====== Exports ====== */
    const importBtn = $("#importCsv");
    const importInput = $("#importCsvInput");
    if (importBtn && importInput) {
      importBtn.addEventListener("click", () => {
        importInput.value = "";
        importInput.click();
        vibrate();
      });
      importInput.addEventListener("change", handleCsvImportChange);
    }

    $("#exportCsv").onclick = () => {
      if (!items.length) return;
      const rows = items.map(({ id, ...c }) => ({
        client: c.client,
        name: c.name,
        qty: c.qty,
        diam: c.diam,
        finish: c.finish,
        type: c.type,
        carton: c.carton,
        deadline: c.deadline ? fmtShortDate(c.deadline) : "",
        status: c.status,
        startTime: c.startTime,
        endTime: c.endTime || "",
        durationSec: c.durationSec || 0,
        note: c.note || "",
      }));
      const header = Object.keys(rows[0]).join(";");
      const body = rows
        .map((r) =>
          Object.values(r)
            .map((v) => `"${String(v ?? "").replace(/"/g, '""')}"`)
            .join(";")
        )
        .join("\n");
      download(
        `badges_vmach_${dateStamp()}.csv`,
        header + "\n" + body,
        "text/csv;charset=utf-8"
      );
      vibrate();
    };

    $("#exportEmail").onclick = () => {
      const withDur = $("#optDur").checked;
      const done = items.filter((i) => i.status === "done");
      if (!done.length) {
        alert("Aucune commande terminée.");
        return;
      }
      const nowTs = now();
      const rows = done
        .map((i) => {
          const durSec = getEffectiveSeconds(i, nowTs);
          const durCell = withDur ? `<td>${fmtDur(durSec)}</td>` : "";
          return `
        <tr>
          <td>${escapeHtml(i.name)}</td>
          <td>${escapeHtml(i.client)}</td>
          <td style="text-align:right">${i.qty}</td>
          <td>${i.diam}</td><td>${i.finish}</td><td>${i.type}</td><td>${i.carton}</td><td>${escapeHtml(i.note || "")}</td>
          <td>${fmtShortDate(i.deadline)}</td><td>${fmtDate(i.startTime)}</td><td>${fmtDate(i.endTime)}</td>
          ${durCell}
        </tr>`;
        })
        .join("");

      const headCols = `<th>Nom</th><th>Client</th><th>Qté</th><th>Format</th><th>Finition</th><th>Attache</th><th>Carton</th><th>Note</th><th>Échéance</th><th>Créé</th><th>Terminé</th>${
        withDur ? "<th>Durée</th>" : ""
      }`;
      const htmlTable = `
        <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;font-family:Inter,Arial,sans-serif;font-size:14px">
          <thead style="background:#f2f5f9"><tr>${headCols}</tr></thead>
          <tbody>${rows}</tbody>
        </table>`;

      const totalQty = done.reduce((sum, i) => sum + (Number(i.qty) || 0), 0);
      const totalActiveSec = Math.floor(done.reduce((sum, i) => sum + getActiveMs(i, nowTs), 0) / 1000);
      const avgSec = done.length ? Math.round(totalActiveSec / done.length) : 0;
      const listLines = done
        .map((i, idx) => {
          const durSec = getEffectiveSeconds(i, nowTs);
          const durLabel = withDur && durSec ? ` • Durée: ${fmtDur(durSec)}` : "";
          const endLabel = fmtDate(i.endTime);
          const endPart = endLabel !== "—" ? ` • Terminé: ${endLabel}` : "";
          const note = (i.note || "").trim();
          const deadlineShort = fmtShortDate(i.deadline);
          const lines = [
            `${idx + 1}. ${i.name} — ${i.client}`,
            `   Qté: ${i.qty} • Format: ${i.diam} • Finition: ${i.finish} • Attache: ${i.type} • Carton: ${i.carton}` +
              (deadlineShort !== "—" ? ` • Échéance: ${deadlineShort}` : ""),
            `   Créé: ${fmtDate(i.startTime)}${endPart}${durLabel}`,
          ];
          if (note) {
            lines.push(`   Note: ${note}`);
          }
          return lines.join("\n");
        })
        .join("\n\n");

      const summaryParts = [
        "Bonjour,",
        "",
        `Voici la synthèse des badges terminés (${done.length} commande${done.length > 1 ? "s" : ""}).`,
        "",
        `Total badges : ${totalQty.toLocaleString("fr-FR")}`,
      ];
      if (withDur && totalActiveSec) {
        summaryParts.push(`Temps actif cumulé : ${fmtDur(totalActiveSec)}`);
      }
      if (withDur && avgSec) {
        summaryParts.push(`Durée moyenne : ${fmtDur(avgSec)}`);
      }
      if (listLines) {
        summaryParts.push("", listLines);
      }
      summaryParts.push(
        "",
        "Le tableau HTML détaillé est copié dans votre presse-papiers pour un collage rapide.",
        "",
        "—",
        "V‑MACH Production Badges"
      );
      const plainBody = summaryParts.filter(Boolean).join("\n");
      const d = new Date();
      const subject = encodeURIComponent(
        `Synthèse badges V‑MACH terminés – ${d.toLocaleDateString("fr-FR")}`
      );
      const body = encodeURIComponent(plainBody);

      const afterCopy = () => {
        window.location.href = `mailto:?subject=${subject}&body=${body}`;
      };
      copyToClipboard(htmlTable).then(afterCopy).catch(afterCopy);
      vibrate();
    };

    function copyToClipboard(html) {
      if (navigator.clipboard && navigator.clipboard.write) {
        const blob = new Blob([html], { type: "text/html" });
        const item = new ClipboardItem({ "text/html": blob });
        return navigator.clipboard.write([item]).catch(() => {
          return navigator.clipboard.writeText(html);
        });
      }
      return navigator.clipboard?.writeText(html) || Promise.resolve();
    }

    function download(name, content, type) {
      const blob = new Blob([content], { type });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function dateStamp() {
      const d = new Date();
      const p = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${p(d.getMonth() + 1)}-${p(d.getDate())}_${p(
        d.getHours()
      )}${p(d.getMinutes())}`;
    }

    /* ====== Confetti (minimal) ====== */
    function confettiBurst() {
      const c = $("#confetti");
      const w = window.innerWidth,
        h = window.innerHeight;
      c.width = w;
      c.height = h;
      c.hidden = false;
      const ctx = c.getContext("2d");
      const parts = [...Array(42)].map(() => ({
        x: w / 2,
        y: 80,
        vx: (Math.random() - 0.5) * 6,
        vy: Math.random() * -4 - 2,
        g: 0.18,
        s: Math.random() * 3 + 2,
        a: 1,
        col: Math.random() > 0.5 ? "#fff" : Math.random() > 0.5 ? "#ffd166" : "#5ab7a4",
      }));
      let t = 0;
      function step() {
        ctx.clearRect(0, 0, w, h);
        parts.forEach((p) => {
          p.vy += p.g;
          p.x += p.vx;
          p.y += p.vy;
          p.a -= 0.01;
          ctx.globalAlpha = Math.max(0, p.a);
          ctx.fillStyle = p.col;
          ctx.fillRect(p.x, p.y, p.s, p.s);
        });
        if (++t < 120) requestAnimationFrame(step);
        else {
          c.hidden = true;
          ctx.clearRect(0, 0, w, h);
        }
      }
      step();
      setTimeout(() => {
        c.hidden = true;
      }, 1800);
    }

    /* ====== Storage sync & Init ====== */
    initPersistentState();

    window.addEventListener("storage", () => {
      items = load().map(enrichItemState);
      lastFormValues = loadLastFormValues();
      formHistory = loadFormHistory();
      seedFormHistoryFromItems(items);
      saveToIndexedDB(items);
      render();
    });
    render();

    /* ====== PWA: register SW ====== */
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./sw.js")
          .then(() => console.log("Service Worker enregistré ✅"))
          .catch(console.error);
      });
    }

    /* ====== Self-tests (console) ====== */
    console.assert(fmtDur(0) === "—" && fmtDur(61).includes("1m"), "fmtDur");
    console.assert(
      statusLabel("wait") === "En attente" && statusLabel("done") === "Terminée",
      "statusLabel"
    );
  </script>
</body>
</html>
